{
  "language": "Solidity",
  "sources": {
    "contracts/aggregator/BaseExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeMath.sol\";\n\nabstract contract BaseExchange {\n    using SafeMath for uint;\n\n    string public name;\n\n    function queryOutput(address tokenIn, address tokenOut, uint amountIn) external virtual view;\n    \n    function swap(address tokenIn, address tokenOut, uint amountIn, uint amountOutMin) external virtual;\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/aggregator/YakRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/SafeMath.sol\";\nimport \"./BaseExchange.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract YakRouter {\n    using SafeMath for uint;\n\n    /// @notice Exchange proxy contracts\n    address[] public exchanges;\n\n    /**\n     * @notice Finds best price from `exchanges`\n     * @param tokenIn input asset\n     * @param tokenOut output asset\n     * @param amountIn input amount\n     * @return exchange address with the best price\n     */\n    // function getOutputAmounts(address tokenIn, address tokenOut, uint amountIn) external returns (uint[] memory) {\n    //     uint[] memory outputAmounts = uint[](exchanges.length);\n    //     for (uint i = 0; i < exchanges.length; i++) {\n    //         outputAmounts[i] = BaseExchange(exchanges[i]).queryOutput(tokenIn, tokenOut, amountIn);\n    //     }\n    //     return outputAmounts;\n    // }\n    \n    /**\n     * @notice Executes a swap\n     * @param tokenIn input asset\n     * @param tokenOut output asset\n     * @param amountIn input amount\n     * @param minAmountOut minimum amount of tokenOut to receive\n     */\n    function swap(address tokenIn, address tokenOut, uint amountIn, uint minAmountOut) external {\n        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\n        uint amountInConfirmed = IERC20(tokenIn).balanceOf(address(this));\n        _swap(tokenIn, tokenOut, amountInConfirmed);\n        uint amountOutConfirmed = IERC20(tokenOut).balanceOf(address(this));\n        require(amountOutConfirmed >= minAmountOut, \"YakRouter::swap, not enough tokens out\");\n        IERC20(tokenOut).transfer(msg.sender, amountOutConfirmed);\n    }\n\n    function _swap(address tokenIn, address tokenOut, uint amountIn) internal {\n\n    }\n\n    function swapWithPermit() external {}\n\n    function addExchange(address exchangeProxy) external {}\n\n    function removeExchange(address exchangeProxy) external {}\n\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/YakVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./strategies/YakStrategy.sol\";\n\n/**\n * @notice YakVault is a managed vault for `deposit tokens`.\n * @dev YakVaults allow managers to manage one or more strategies.\n * @dev Strategies should be primarly \"neutral\" with fees collected at the Vault level.\n * @dev Vaults accepts deposits in the form of `deposit tokens` OR `strategy tokens`.\n */\ncontract YakVault is YakERC20 {\n    using SafeMath for uint;\n\n    /// @notice Vault version number\n    string public constant version = \"0.0.1\";\n\n    address public owner;\n    address public depositToken;\n    address public activeStrategy;\n\n    mapping(address => bool) supportedDepositTokens;\n    address[] public supportedStrategies;\n\n    constructor (\n        string memory _name,\n        address _depositToken\n    ) {\n        name = _name;\n        depositToken = _depositToken;\n\n        owner = msg.sender;\n        supportedDepositTokens[_depositToken] = true;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"YakVault::onlyOwner\");\n        _;\n    }\n\n    /**\n     * @notice Deposit to currently active strategy\n     */\n    function deposit(address token, uint amount) external {\n        require(supportedDepositTokens[token], \"YakVault::deposit, token not supported\");\n        if (token == depositToken) {\n            YakStrategy(activeStrategy).deposit(amount);\n        }\n        // todo: event\n    }\n\n    /**\n     * @notice Withdraw from strategies\n     */\n    function withdraw(uint amount) external {\n        // todo: event\n    }\n\n    /**\n     * @notice Set an active strategy\n     * @dev\n     * @param strategy address for new strategy\n     */\n    function setActiveStrategy(address strategy) public onlyOwner {\n        require(supportedDepositTokens[strategy], \"YakVault::setActiveStrategy, not found\");\n        require(IERC20(depositToken).approve(activeStrategy, 0));\n        require(IERC20(depositToken).approve(strategy, uint(-1)));\n        activeStrategy = strategy;\n        // todo: event\n    }\n\n    function addStrategy(address strategy) public onlyOwner {\n        // todo: checks\n        require(true && true, \"YakVault::addStrategy not compatible\");\n        supportedDepositTokens[strategy] = true;\n        // todo: approve\n        // todo: event\n    }\n\n    function removeStrategy(address strategy) public onlyOwner {\n        require(strategy != depositToken, \"YakVault::removeStrategy, cannot remove deposit token\");\n        supportedDepositTokens[strategy] = false;\n        // todo: event\n    }\n\n    function getDeployedFunds() public view returns (uint) {\n        uint deployedFunds = 0;\n        for (uint i = 0; i < supportedStrategies.length; i++) {\n            // todo\n            // uint deployedInStrategy = supportedStrategies[i].getDeployedBalance();\n            // deployedFunds = deployedFunds.add(deployedInStrategy);\n        }\n        return deployedFunds;\n    }\n}"
    },
    "contracts/YakERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\n\nabstract contract YakERC20 {\n    using SafeMath for uint256;\n\n    string public name = \"Yield Yak\";\n    string public symbol = \"YRT\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n  \n    mapping (address => mapping (address => uint256)) internal allowances;\n    mapping (address => uint256) internal balances;\n\n    /// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// keccak256(\"1\");\n    bytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    mapping(address => uint) public nonces;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {}\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * It is recommended to use increaseAllowance and decreaseAllowance instead\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowances[src][spender];\n\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = spenderAllowance.sub(amount, \"transferFrom: transfer amount exceeds allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n\n    /**\n     * @notice Approval implementation\n     * @param owner The address of the account which owns tokens\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"_approve::owner zero address\");\n        require(spender != address(0), \"_approve::spender zero address\");\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Transfer implementation\n     * @param from The address of the account which owns tokens\n     * @param to The address of the account which is receiving tokens\n     * @param value The number of tokens that are being transferred\n     */\n    function _transferTokens(address from, address to, uint256 value) internal {\n        require(to != address(0), \"_transferTokens: cannot transfer to the zero address\");\n\n        balances[from] = balances[from].sub(value, \"_transferTokens: transfer exceeds from balance\");\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balances[from] = balances[from].sub(value, \"_burn: burn amount exceeds from balance\");\n        totalSupply = totalSupply.sub(value, \"_burn: burn amount exceeds total supply\");\n        emit Transfer(from, address(0), value);\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spender\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param value The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"permit::expired\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @notice Recovers address from signed data and validates the signature\n     * @param signer Address that signed the data\n     * @param encodeData Data signed by the address\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"Arch::validateSig: invalid signature\");\n    }\n\n    /**\n     * @notice EIP-712 Domain separator\n     * @return Separator\n     */\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                VERSION_HASH,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Current id of the chain where this contract is deployed\n     * @return Chain id\n     */\n    function _getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "contracts/strategies/YakStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../lib/SafeMath.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../YakERC20.sol\";\n\n// DRAFT for discussion\n\nabstract contract YakStrategy is YakERC20 {\n    using SafeMath for uint;\n\n    IERC20 public depositToken;\n    IERC20 public rewardToken;\n    address public strategyManager;\n    // address public devAddr;\n\n    uint constant internal BIPS_DIVISOR = 10000;\n    uint constant internal UINT_MAX = uint(-1);\n\n    /**\n     * @dev May only be called by `strategyManager`\n     */\n    modifier onlyManager() {\n        require(msg.sender == strategyManager, \"onlyManager\");\n        _;\n    }\n\n    /**\n     * @notice Approve tokens for use in Strategy\n     * @dev Restricted to avoid griefing attacks\n     */\n    function setAllowances() public virtual;\n\n    /**\n     * @notice Revoke token allowance\n     * @dev Restricted to avoid griefing attacks\n     * @param token address\n     * @param spender address\n     */\n    function revokeAllowance(address token, address spender) external onlyManager {\n        require(IERC20(token).approve(spender, 0), \"YakStrategy::revokeAllowance\");\n    }\n\n    /**\n     * @notice Deposits `depositToken` to strategy\n     * @param amount deposit tokens to deposit\n     */\n    function deposit(uint amount) external virtual;\n\n    /**\n     * @notice Deposit `depositToken` to strategy for another account\n     * @param account address to receive receipt tokens\n     * @param amount deposit tokens to deposit\n     */\n    function depositFor(address account, uint amount) external virtual;\n\n    /**\n     * @notice Withdraws `depositTokens` from strategy\n     * @param amount deposit tokens to withdraw from strategy\n     */\n    function withdraw(uint amount) external virtual;\n\n    /**\n     * @notice Withdraws `depositTokens` from strategy to another account\n     * @param account account to receive deposit tokens\n     * @param amount deposit tokens to withdraw from strategy\n     */\n    function withdrawTo(address account, uint amount) external virtual;\n\n    /**\n     * @notice Reinvests `rewardToken` to `depositToken`\n     * @return deposit tokens received\n     */\n    function reinvest() external virtual returns (uint);\n\n    /**\n     * @notice Estimate reinvest reward for caller\n     * @return Estimated rewards tokens earned for calling `reinvest()`\n     */\n    function estimateReinvestReward() external virtual view returns (uint);\n\n    /**\n     * @notice Reward token balance that can be reinvested\n     * @return reward tokens\n     */\n    function checkReward() public virtual view returns (uint);\n\n    /**\n     * @notice Helper function to get the current balance deployed by strategy\n     * @dev This must NOT include the strategy contract balance\n     * @return deposit tokens\n     */\n    function getDeployedBalance() external virtual view returns (uint);\n\n    /**\n     * @notice Rescue all available deployed deposit tokens back to Strategy\n     * @dev This must NOT transfer tokens out of the strategy contract\n     */\n    function rescueDeployedFunds() external virtual;\n\n    /**\n     * @notice Recover ERC20 from contract\n     * @param tokenAddress token address\n     * @param tokenAmount amount to recover\n     */\n    function recoverERC20(address tokenAddress, uint tokenAmount) external onlyManager {\n        require(tokenAmount > 0, 'YakStrategy::recoverERC20, amount too low');\n        require(IERC20(tokenAddress).transfer(msg.sender, tokenAmount));\n    }\n\n    /**\n     * @notice Recover AVAX from contract\n     * @param amount amount\n     */\n    function recoverAVAX(uint amount) external onlyManager {\n        require(amount > 0, 'YakStrategy::recoverAVAX, amount too low');\n        msg.sender.transfer(amount);\n    }\n\n}"
    },
    "contracts/aggregator/exchanges/PandaSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../BaseExchange.sol\";\nimport \"../../interfaces/IRouter.sol\";\nimport \"../../lib/SafeMath.sol\";\n\ncontract PandaSwap is BaseExchange {\n    \n    // name = \"PandaSwap\";\n    address public router;\n\n    constructor (\n        address _router\n    ) {\n        router = _router;\n    }\n\n    function queryOutput(address tokenIn, address tokenOut, uint amountIn) external override view {\n        // IRouter(router).getAmountsOut(amountIn, path);\n    }\n    \n    function swap(address tokenIn, address tokenOut, uint amountIn, uint amountOutMin) external override {\n        address to = msg.sender;\n        uint deadline = block.timestamp;\n        // IRouter(router).swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline);\n    }\n}"
    },
    "contracts/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IRouter {\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(address token, uint amountTokenDesired, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountAVAX);\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/timelocks/YakTimelockForDexStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IStrategy {\n    function owner() external view returns (address);\n    function renounceOwnership() external;\n    function transferOwnership(address newOwner) external;\n    function emergencyWithdraw() external;\n    function updateMinTokensToReinvest(uint newValue) external;\n    function updateAdminFee(uint newValue) external;\n    function updateReinvestReward(uint newValue) external;\n    function recoverERC20(address tokenAddress, uint tokenAmount) external;\n    function recoverAVAX(uint amount) external;\n}\n\ncontract YakTimelockForDexStrategy {\n\n    uint public constant timelockLengthForAssetRecovery = 10 minutes;\n    uint public constant timelockLengthForOwnershipTransfer = 15 minutes;\n    uint public constant timelockLengthForFeeChanges = 5 minutes;\n\n    address public manager;\n    address public feeCollector;\n    IStrategy public strategy;\n\n    address public pendingOwner;\n    uint public pendingAdminFee;\n    uint public pendingReinvestReward;\n    address public pendingTokenAddressToRecover;\n    uint public pendingTokenAmountToRecover;\n    uint public pendingAVAXToRecover;\n\n    event ProposeOwner(address indexed proposedValue, uint timelock);\n    event ProposeAdminFee(uint proposedValue, uint timelock);\n    event ProposeReinvestReward(uint proposedValue, uint timelock);\n    event ProposeRecovery(address indexed proposedToken, uint proposedValue, uint timelock);\n\n    event SetOwner(address newValue);\n    event SetAdminFee(uint newValue);\n    event SetReinvestReward(uint newValue);\n    event SetMinTokensToReinvest(uint newValue);\n    event Sweep(address indexed token, uint amount);\n    event Recover(address indexed token, uint amount);\n    event EmergencyWithdraw();\n\n    enum Functions {\n        renounceOwnership,\n        transferOwnership,\n        emergencyWithdraw,\n        updateMinTokensToReinvest,\n        updateAdminFee,\n        updateReinvestReward,\n        recoverERC20,\n        recoverAVAX\n    }\n\n    mapping(Functions => uint) public timelock;\n\n    constructor(\n        address _strategy\n    ) {\n        manager = msg.sender;\n        feeCollector = msg.sender;\n        strategy = IStrategy(_strategy);\n    }\n\n    // Modifiers\n\n    /**\n     * @notice Restrict to `manager`\n     * @dev To change manager, deploy new timelock and transfer strategy ownership\n     */\n    modifier onlyManager {\n        require(msg.sender == manager);\n        _;\n    }\n\n    /**\n     * @notice Restrict to `feeCollector`\n     * @dev To change feeCollector, deploy new timelock and transfer strategy ownership\n     */\n    modifier onlyFeeCollector {\n        require(msg.sender == feeCollector);\n        _;\n    }\n\n    /**\n     * @notice Set timelock when changing pending values\n     * @param _fn Function enum value\n     * @param timelockLength in seconds\n     */\n    modifier setTimelock(Functions _fn, uint timelockLength) {\n        timelock[_fn] = block.timestamp + timelockLength;\n        _;\n    }\n\n    /**\n     * @notice Enforce timelock for a given function\n     * @dev Ends execution by resetting timelock to avoid replay\n     * @param _fn Function enum value\n     */\n    modifier enforceTimelock(Functions _fn) {\n        require(timelock[_fn] != 0 && timelock[_fn] <= block.timestamp, \"YakTimelockManagerV1::enforceTimelock\");\n        _;\n        timelock[_fn] = 0;\n    }\n\n    /**\n     * @notice Sweep tokens from the timelock to `feeCollector`\n     * @dev The timelock contract may receive assets from both revenue and asset recovery.\n     * @dev The sweep function is NOT timelocked, because recovered assets must go through separate timelock functions.\n     * @param tokenAddress address\n     * @param tokenAmount amount\n     */\n    function sweepTokens(address tokenAddress, uint tokenAmount) external onlyFeeCollector {\n        require(tokenAmount > 0, 'YakTimelockManagerV1::sweepTokens, amount too low');\n        require(IERC20(tokenAddress).transfer(msg.sender, tokenAmount), 'YakTimelockManagerV1::sweepTokens, transfer failed');\n        emit Sweep(tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Sweep AVAX from the timelock to the `feeCollector` address\n     * @dev The timelock contract may receive assets from both revenue and asset recovery.\n     * @dev The sweep function is NOT timelocked, because recovered assets must go through separate timelock functions.\n     * @param amount amount\n     */\n    function sweepAVAX(uint amount) external onlyFeeCollector {\n        require(amount > 0, 'YakTimelockManagerV1::sweepAVAX, amount too low');\n        msg.sender.transfer(amount);\n        emit Sweep(address(0), amount);\n    }\n\n    // Functions with timelocks\n\n    /**\n     * @notice Pass new value of `owner` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _pendingOwner new value\n     */\n    function proposeOwner(address _pendingOwner) external onlyManager setTimelock(Functions.transferOwnership, timelockLengthForOwnershipTransfer) {\n        pendingOwner = _pendingOwner;\n        emit ProposeOwner(_pendingOwner, timelock[Functions.transferOwnership]);\n    }\n\n    /**\n     * @notice Set new value of `owner` and resets timelock\n     * @dev This can be called by anyone\n     */\n    function setOwner() external enforceTimelock(Functions.transferOwnership) {\n        strategy.transferOwnership(pendingOwner);\n        emit SetOwner(pendingOwner);\n        pendingOwner = address(0);\n    }\n\n    /**\n     * @notice Pass new value of `adminFee` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _pendingAdminFee new value\n     */\n    function proposeAdminFee(uint _pendingAdminFee) external onlyManager setTimelock(Functions.updateAdminFee, timelockLengthForFeeChanges) {\n        pendingAdminFee = _pendingAdminFee;\n        emit ProposeAdminFee(_pendingAdminFee, timelock[Functions.updateAdminFee]);\n    }\n\n    /**\n     * @notice Set new value of `adminFee` and reset timelock\n     * @dev This can be called by anyone\n     */\n    function setAdminFee() external enforceTimelock(Functions.updateAdminFee) {\n        strategy.updateAdminFee(pendingAdminFee);\n        emit SetAdminFee(pendingAdminFee);\n        pendingAdminFee = 0;\n    }\n\n    /**\n     * @notice Pass new value of `reinvestReward` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _pendingReinvestReward new value\n     */\n    function proposeReinvestReward(uint _pendingReinvestReward) external onlyManager setTimelock(Functions.updateReinvestReward, timelockLengthForFeeChanges) {\n        pendingReinvestReward = _pendingReinvestReward;\n        emit ProposeReinvestReward(_pendingReinvestReward, timelock[Functions.updateReinvestReward]);\n    }\n\n    /**\n     * @notice Set new value of `reinvestReward` and reset timelock\n     * @dev This can be called by anyone\n     */\n    function setReinvestReward() external enforceTimelock(Functions.updateReinvestReward) {\n        strategy.updateReinvestReward(pendingReinvestReward);\n        emit SetReinvestReward(pendingReinvestReward);\n        pendingReinvestReward = 0;\n    }\n\n    /**\n     * @notice Pass values for `recoverERC20` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _pendingTokenAddressToRecover address\n     * @param _pendingTokenAmountToRecover amount\n     */\n    function proposeRecoverERC20(address _pendingTokenAddressToRecover, uint _pendingTokenAmountToRecover) external onlyManager setTimelock(Functions.recoverERC20, timelockLengthForAssetRecovery) {\n        pendingTokenAddressToRecover = _pendingTokenAddressToRecover;\n        pendingTokenAmountToRecover = _pendingTokenAmountToRecover;\n        emit ProposeRecovery(_pendingTokenAddressToRecover, _pendingTokenAmountToRecover, timelock[Functions.recoverERC20]);\n    }\n\n    /**\n     * @notice Call `recoverERC20` and reset timelock\n     * @dev This can be called by anyone\n     * @dev Recoverd funds are collected to this timelock and may be swept\n     */\n    function setRecoverERC20() external enforceTimelock(Functions.recoverERC20) {\n        strategy.recoverERC20(pendingTokenAddressToRecover, pendingTokenAmountToRecover);\n        emit Recover(pendingTokenAddressToRecover, pendingTokenAmountToRecover);\n        pendingTokenAddressToRecover = address(0);\n        pendingTokenAmountToRecover = 0;\n    }\n\n    /**\n     * @notice Pass values for `recoverAVAX` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _pendingAVAXToRecover amount\n     */\n    function proposeRecoverAVAX(uint _pendingAVAXToRecover) external onlyManager setTimelock(Functions.recoverAVAX, timelockLengthForAssetRecovery) {\n        pendingAVAXToRecover = _pendingAVAXToRecover;\n        emit ProposeRecovery(address(0), _pendingAVAXToRecover, timelock[Functions.recoverAVAX]);\n    }\n\n    /**\n     * @notice Call `recoverAVAX` and reset timelock\n     * @dev This can be called by anyone\n     * @dev Recoverd funds are collected to this timelock and may be swept\n     */\n    function setRecoverAVAX() external enforceTimelock(Functions.recoverAVAX) {\n        strategy.recoverAVAX(pendingAVAXToRecover);\n        emit Recover(address(0), pendingAVAXToRecover);\n        pendingAVAXToRecover = 0;\n    }\n\n    // Functions without timelocks\n\n    /**\n     * @notice Set new value of `minTokensToReinvest`\n     * @dev Restricted to `manager` to avoid griefing\n     * @param minTokensToReinvest new value\n     */\n    function setMinTokensToReinvest(uint minTokensToReinvest) external onlyManager {\n        strategy.updateMinTokensToReinvest(minTokensToReinvest);\n        emit SetMinTokensToReinvest(minTokensToReinvest);\n    }\n\n    /**\n     * @notice Rescues deployed assets to the strategy contract\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev In case of emergency, assets will be transferred to the timelock and may be swept\n     */\n    function emergencyWithdraw() external onlyManager {\n        strategy.emergencyWithdraw();\n        emit EmergencyWithdraw();\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}