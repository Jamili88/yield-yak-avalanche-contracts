{
  "language": "Solidity",
  "sources": {
    "contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/Ownable.sol\";\nimport \"./strategies/BaseStrategy.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract Vault is YakERC20, Ownable {\n    using SafeMath for uint;\n\n    /// @notice Vault version number\n    string public constant version = \"0.0.1\";\n\n    /// @notice Total amount of `depositToken` managed by Vault\n    uint public totalDeposits;\n\n    /// @notice Deposit token\n    IERC20 public depositToken;\n\n    /// @notice Strategy contract\n    address public strategyContract;\n\n    /// @notice Admin role to update strategy (separate to `owner`)\n    address public strategyUpdater;\n\n    /// @notice Event emitted after successful `deposit()`\n    event Deposit(address indexed account, uint amount);\n\n    /// @notice Event emitted after successful `withdraw()`\n    event Withdraw(address indexed account, uint amount);\n\n    /// @notice Event emitted after reinvest. Used to track growth\n    event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n\n    /// @notice Event emitted when Vault tokens are recovered\n    event Recovered(address indexed token, uint amount);\n\n    /// @notice Event emitted when `strategyContract` is updated\n    event UpdateStrategy(address indexed oldValue, address indexed newValue);\n\n    /// @notice Event emitted when `strategyUpdater` is updated\n    event TransferStrategyUpdaterRole(address indexed oldValue, address indexed newValue);\n\n    constructor (\n        string memory _name,\n        address _depositToken\n    ) {\n        name = _name;\n        depositToken = IERC20(_depositToken);\n\n        strategyUpdater = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by smart contract\n     */\n    modifier onlyEOA() {\n        require(tx.origin == msg.sender, \"Vault::onlyEOA, invalid msg.sender\");\n        _;\n    }\n\n    /**\n     * @dev May only be called by `strategyUpdater`\n     */\n    modifier onlyStrategyUpdater() {\n        require(msg.sender != address(0), \"Vault::onlyStrategyUpdater, invalid msg.sender\");\n        require(msg.sender == strategyUpdater, \"Vault::onlyStrategyUpdater, not strategy updater\");\n        _;\n    }\n\n    /**\n     * @notice Revoke token allowance\n     * @dev Restricted to owner to avoid griefing attacks\n     * @param token address\n     * @param spender address\n     */\n    function revokeAllowance(address token, address spender) external onlyOwner {\n        require(IERC20(token).approve(spender, 0));\n    }\n\n    /**\n     * @notice Deposit tokens to receive receipt tokens\n     * @param amount Amount of tokens to deposit\n     */\n    function deposit(uint amount) external {\n        _deposit(msg.sender, amount);\n    }\n\n    /**\n     * @notice Deposit on behalf of another address\n     * @param account address to receipt receipt tokens\n     * @param amount Amount of tokens to deposit\n     */\n    function depositOnBehalfOf(address account, uint amount) external {\n        _deposit(account, amount);\n    }\n\n    /**\n     * @notice Deposit using Permit\n     * @param amount Amount of tokens to deposit\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n        _deposit(msg.sender, amount);\n    }\n\n    /**\n     * @notice Private function to handle user deposits\n     * @dev If there is no strategy, deposits are held in Vault\n     * @param account address to receive receipt tokens\n     * @param amount deposit tokens to deposit\n     */\n    function _deposit(address account, uint amount) private {\n        require(amount > 0, \"Vault::_deposit, amount too low\");\n        require(depositToken.transferFrom(msg.sender, address(this), amount), \"Vault::_deposit, transferFrom failed\");\n        if (strategyContract != address(0)) {\n            BaseStrategy(strategyContract).deposit(amount);\n        }\n        _mint(account, getSharesForDepositTokens(amount));\n        totalDeposits = totalDeposits.add(amount);\n        emit Deposit(account, amount);\n    }\n\n    /**\n     * @notice Withdraw deposit tokens by redeeming receipt tokens\n     * @dev If strategy is set, tries to withdraw from strategy\n     * @dev If strategy is NOT set, tries to withdraw from vault\n     * @param amount receipt tokens to redeem\n     */\n    function withdraw(uint amount) external {\n        require(amount > 0, \"Vault::withdraw, amount too low\");\n        uint depositTokenAmount = getDepositTokensForShares(amount);\n        require(depositTokenAmount > 0, \"Vault::withdraw, deposit amount too low\");\n        if (strategyContract != address(0)) {\n            BaseStrategy(strategyContract).withdraw(msg.sender, depositTokenAmount);\n        }\n        else if (depositToken.balanceOf(address(this)) >= depositTokenAmount) {\n            require(depositToken.transfer(msg.sender, depositTokenAmount), \"Vault::withdraw, transfer failed\");\n        }\n        else {\n            revert(\"Vault::withdraw, failed\");\n        }\n        _burn(msg.sender, amount);\n        totalDeposits = totalDeposits.sub(depositTokenAmount);\n        emit Withdraw(msg.sender, depositTokenAmount);\n    }\n\n    /**\n     * @notice Reinvest rewards from staking contract to deposit tokens\n     */\n    function reinvest() external onlyEOA {\n        require(strategyContract != address(0), \"Vault::reinvest, no strategy\");\n        uint depositTokensAdded = BaseStrategy(strategyContract).reinvest();\n        require(depositTokensAdded > 0, \"Vault::reinvest, not enough deposit tokens\");\n        totalDeposits = totalDeposits.add(depositTokensAdded);\n        emit Reinvest(totalDeposits, totalSupply);\n    }\n\n    /**\n     * @notice Estimate reinvest reward for caller\n     * @return Estimated rewards tokens earned for calling `reinvest()`\n     */\n    function estimateReinvestReward() external view returns (uint) {\n        if (strategyContract == address(0)) {\n            return 0;\n        }\n        return BaseStrategy(strategyContract).estimateReinvestReward();\n    }\n\n    /**\n     * @notice Reward token balance that can be reinvested\n     * @return Reward token balance that can be reinvested\n     */\n    function checkReward() external view returns (uint) {\n        if (strategyContract == address(0)) {\n            return 0;\n        }\n        return BaseStrategy(strategyContract).checkReward();\n    }\n\n    /**\n     * @notice Calculate receipt tokens for a given amount of deposit tokens\n     * @dev If contract is empty, use 1:1 ratio\n     * @dev Could return zero shares for very low amounts of deposit tokens\n     * @param amount deposit tokens\n     * @return receipt tokens\n     */\n    function getSharesForDepositTokens(uint amount) public view returns (uint) {\n        if (totalSupply.mul(totalDeposits) == 0) {\n            return amount;\n        }\n        return amount.mul(totalSupply).div(totalDeposits);\n    }\n\n    /**\n     * @notice Calculate deposit tokens for a given amount of receipt tokens\n     * @param amount receipt tokens\n     * @return deposit tokens\n     */\n    function getDepositTokensForShares(uint amount) public view returns (uint) {\n        if (totalSupply.mul(totalDeposits) == 0) {\n            return 0;\n        }\n        return amount.mul(totalDeposits).div(totalSupply);\n    }\n\n    /**\n     * @notice Revoke deployed `depositTokens` back into Vault\n     * @param strategy address\n     */\n    function revokeDeployedFunds(address strategy) external onlyOwner {\n        BaseStrategy(strategy).rescueDeployedFunds();\n        BaseStrategy(strategy).recoverERC20(\n            address(depositToken), depositToken.balanceOf(strategy)\n        );\n    }\n\n    /**\n     * @notice Sweeps tokens from Strategy to Vault\n     * @param strategy address\n     * @param tokens list of token addresses\n     */\n    function sweepTokensFrom(address strategy, address[] calldata tokens) external onlyOwner {\n        for(uint i = 0; i < tokens.length; i++) {\n            if (tokens[i] == address(0)) {\n                BaseStrategy(strategy).recoverAVAX(\n                    address(this).balance\n                );\n            }\n            else {\n                IERC20 token = IERC20(tokens[i]);\n                BaseStrategy(strategy).recoverERC20(\n                    tokens[i], \n                    token.balanceOf(strategy)\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Deploy funds from Vault into a Strategy\n     * @dev Intended for use as part of an upgrade process\n     * @dev Does not affect `totalDeposits` nor mint receipt tokens\n     */\n    function deployStrategyFunds(uint amount) external onlyStrategyUpdater {\n        require(strategyContract != address(0), \"Vault::deployStrategyFunds, no strategy\");\n        BaseStrategy(strategyContract).deposit(amount);\n    }\n\n    /**\n     * @notice Revokes current strategy\n     */\n    function revokeStrategy() external onlyStrategyUpdater {\n        require(strategyContract != address(0), \"Vault::revokeStrategy, no strategy\");\n        require(depositToken.approve(strategyContract, 0));\n        emit UpdateStrategy(strategyContract, address(0));\n        strategyContract = address(0);\n    }\n\n    /**\n     * @notice Updates strategy contract\n     * @dev Checks for matching `vault` and `depositToken` values\n     * @param newStrategy contract address of new strategy\n     */\n    function updateStrategy(address newStrategy) external onlyStrategyUpdater {\n        require(newStrategy != address(0), \"Vault::updateStrategy, use revokeStrategy() instead\");\n        require(\n            BaseStrategy(newStrategy).vault() == address(this)\n            && BaseStrategy(newStrategy).depositToken() == depositToken,\n            \"Vault::updateStrategy, incompatible strategy\");\n        require(depositToken.approve(newStrategy, uint256(-1)));\n        emit UpdateStrategy(strategyContract, newStrategy);\n        strategyContract = newStrategy;\n    }\n\n    /**\n     * @notice Transfer admin role `strategyUpdater`\n     * @dev Set value to address(0) to disable the role and prevent future transfers\n     * @param newStrategyUpdater address of new strategy updater\n     */\n    function transferStrategyUpdaterRole(address newStrategyUpdater) external onlyStrategyUpdater {\n        emit TransferStrategyUpdaterRole(strategyUpdater, newStrategyUpdater);\n        strategyUpdater = newStrategyUpdater;\n    }\n\n    /**\n     * @notice Recover ERC20 from Vault\n     * @dev Cannot be used to recover deposit tokens\n     * @param tokenAddress token address\n     * @param tokenAmount amount to recover\n     */\n    function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n        require(tokenAddress != address(depositToken), \"Vault::recoverERC20, cannot recover deposit token\");\n        require(tokenAmount > 0, \"Vault::recoverERC20, amount too low\");\n        require(IERC20(tokenAddress).transfer(msg.sender, tokenAmount), \"Vault::recoverERC20, transfer failed\");\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Recover AVAX from Vault\n     * @param amount amount to recover\n     */\n    function recoverAVAX(uint amount) external onlyOwner {\n        require(amount > 0, \"Vault::recoverAVAX, amount too low\");\n        require(amount <= address(this).balance, \"Vault::recoverAVAX, amount too high\");\n        msg.sender.transfer(amount);\n        emit Recovered(address(0), amount);\n    }\n        \n}"
    },
    "contracts/YakERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\n\nabstract contract YakERC20 {\n    using SafeMath for uint256;\n\n    string public name = \"Yield Yak\";\n    string public symbol = \"YRT\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n  \n    mapping (address => mapping (address => uint256)) internal allowances;\n    mapping (address => uint256) internal balances;\n\n    /// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// keccak256(\"1\");\n    bytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    mapping(address => uint) public nonces;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {}\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * It is recommended to use increaseAllowance and decreaseAllowance instead\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowances[src][spender];\n\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = spenderAllowance.sub(amount, \"transferFrom: transfer amount exceeds allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n\n    /**\n     * @notice Approval implementation\n     * @param owner The address of the account which owns tokens\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"_approve::owner zero address\");\n        require(spender != address(0), \"_approve::spender zero address\");\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Transfer implementation\n     * @param from The address of the account which owns tokens\n     * @param to The address of the account which is receiving tokens\n     * @param value The number of tokens that are being transferred\n     */\n    function _transferTokens(address from, address to, uint256 value) internal {\n        require(to != address(0), \"_transferTokens: cannot transfer to the zero address\");\n\n        balances[from] = balances[from].sub(value, \"_transferTokens: transfer exceeds from balance\");\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balances[from] = balances[from].sub(value, \"_burn: burn amount exceeds from balance\");\n        totalSupply = totalSupply.sub(value, \"_burn: burn amount exceeds total supply\");\n        emit Transfer(from, address(0), value);\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spender\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param value The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"permit::expired\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @notice Recovers address from signed data and validates the signature\n     * @param signer Address that signed the data\n     * @param encodeData Data signed by the address\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"Arch::validateSig: invalid signature\");\n    }\n\n    /**\n     * @notice EIP-712 Domain separator\n     * @return Separator\n     */\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                VERSION_HASH,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Current id of the chain where this contract is deployed\n     * @return Chain id\n     */\n    function _getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"
    },
    "contracts/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../lib/SafeMath.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nabstract contract BaseStrategy {\n    using SafeMath for uint;\n\n    IERC20 public depositToken;\n    IERC20 public rewardToken;\n    address public vault;\n    address public strategyManager;\n    string public name;\n\n    uint constant internal BIPS_DIVISOR = 10000;\n    uint constant internal UINT_MAX = uint256(-1);\n\n    /**\n     * @dev May only be called by `vault`\n     */\n    modifier onlyVault() {\n        require(msg.sender == vault, \"onlyVault\");\n        _;\n    }\n\n    /**\n     * @dev May only be called by `strategyManager`\n     */\n    modifier onlyManager() {\n        require(msg.sender == strategyManager, \"onlyManager\");\n        _;\n    }\n\n    /**\n     * @dev May only be called by `strategyManager` or `vault`\n     */\n    modifier onlyManagerOrVault() {\n        require(\n            msg.sender == strategyManager\n            || msg.sender == vault\n            , \"onlyManagerOrVault\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Approve tokens for use in Strategy\n     * @dev Restricted to avoid griefing attacks\n     */\n    function setAllowances() public virtual;\n\n    /**\n     * @notice Revoke token allowance\n     * @dev Restricted to avoid griefing attacks\n     * @param token address\n     * @param spender address\n     */\n    function revokeAllowance(address token, address spender) external onlyManager {\n        require(IERC20(token).approve(spender, 0));\n    }\n\n    /**\n     * @notice Deposits `depositToken` to strategy\n     * @param amount deposit tokens to deposit to strategy\n     */\n    function deposit(uint amount) external virtual;\n\n    /**\n     * @notice Withdraws `depositTokens` from strategy\n     * @param account account to receive deposit tokens\n     * @param amount deposit tokens to withdraw from strategy\n     */\n    function withdraw(address account, uint amount) external virtual;\n\n    /**\n     * @notice Reinvests `rewardToken` to `depositToken`\n     * @return deposit tokens received\n     */\n    function reinvest() external virtual returns (uint);\n\n    /**\n     * @notice Estimate reinvest reward for caller\n     * @return Estimated rewards tokens earned for calling `reinvest()`\n     */\n    function estimateReinvestReward() external virtual view returns (uint);\n\n    /**\n     * @notice Reward token balance that can be reinvested\n     * @return reward tokens\n     */\n    function checkReward() public virtual view returns (uint);\n\n    /**\n     * @notice Helper function to get the current balance deployed by strategy\n     * @dev This must NOT include the strategy contract balance\n     * @return deposit tokens\n     */\n    function getDeployedBalance() external virtual view returns (uint);\n\n    /**\n     * @notice Rescue all available deployed deposit tokens back to Strategy\n     * @dev This is should NOT transfer tokens out of the strategy contract\n     */\n    function rescueDeployedFunds() external virtual;\n\n    /**\n     * @notice Recover ERC20 from contract\n     * @param tokenAddress token address\n     * @param tokenAmount amount to recover\n     */\n    function recoverERC20(address tokenAddress, uint tokenAmount) external onlyVault {\n        require(tokenAmount > 0, 'Strategy::recoverERC20, amount too low');\n        require(IERC20(tokenAddress).transfer(msg.sender, tokenAmount));\n    }\n\n    /**\n     * @notice Recover AVAX from contract\n     * @param amount amount\n     */\n    function recoverAVAX(uint amount) external onlyVault {\n        require(amount > 0, 'Strategy::recoverAVAX, amount too low');\n        require(amount <= address(this).balance, \"Strategy::recoverAVAX, amount too high\");\n        msg.sender.transfer(amount);\n    }\n\n}"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IStakingRewards {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function lastTimeRewardApplicable() external view returns (uint256);\n    function rewardPerToken() external view returns (uint256);\n    function earned(address account) external view returns (uint256);\n    function getRewardForDuration() external view returns (uint256);\n    function stake(uint256 amount) external;\n    function stakeWithPermit(uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function withdraw(uint256 amount) external;\n    function getReward() external;\n    function exit() external;\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n}"
    },
    "contracts/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IRouter {\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(address token, uint amountTokenDesired, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountAVAX);\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/interfaces/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\n\ninterface IPair is IERC20 {\n    function token0() external pure returns (address);\n    function token1() external pure returns (address);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/lib/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"
    },
    "contracts/strategies/BambooLPWithReinvestFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IBambooChef.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract BambooLPWithReinvestFee is BaseStrategy {\n    using SafeMath for uint;\n\n    uint public PID;\n    uint public REINVEST_REWARD_BIPS = 500;\n    uint public ADMIN_FEE_BIPS = 500;\n    uint public MIN_TOKENS_TO_REINVEST = 20000;\n\n    address public feeCollector;\n    IBambooChef public stakingContract;\n    IRouter public router;\n\n    event UpdateAdminFee(uint oldValue, uint newValue);\n    event UpdateReinvestReward(uint oldValue, uint newValue);\n    event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n\n    constructor(\n        string memory _name,\n        address _vault,\n        address _depositToken,\n        address _rewardToken,\n        address _stakingContract,\n        address _router,\n        uint _pid\n    ) {\n        vault = _vault;\n        depositToken = IERC20(_depositToken);\n        rewardToken = IERC20(_rewardToken);\n\n        stakingContract = IBambooChef(_stakingContract);\n        router = IRouter(_router);\n        PID = _pid;\n\n        strategyManager = msg.sender;\n        feeCollector = msg.sender;\n\n        name = _name;\n        setAllowances();\n    }\n\n    function setAllowances() public override onlyManager {\n        depositToken.approve(vault, UINT_MAX);\n        depositToken.approve(address(stakingContract), UINT_MAX);\n        depositToken.approve(address(router), UINT_MAX);\n\n        IERC20 token0 = IERC20(IPair(address(depositToken)).token0());\n        token0.approve(address(router), UINT_MAX);\n\n        IERC20 token1 = IERC20(IPair(address(depositToken)).token1());\n        token1.approve(address(router), UINT_MAX);\n    }\n\n    function deposit(uint amount) external override onlyVault {\n        require(depositToken.transferFrom(msg.sender, address(this), amount), \"Strategy::deposit, transferFrom failed\");\n        _stakeDepositTokens(amount);\n    }\n\n    function withdraw(address account, uint amount) external override onlyVault {\n        _withdrawDepositTokens(amount);\n        require(depositToken.transfer(account, amount), \"Strategy::withdraw, transfer failed\");\n    }\n\n    function reinvest() external override onlyVault returns (uint) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards < MIN_TOKENS_TO_REINVEST) {\n            return 0;\n        }\n        return _reinvest(unclaimedRewards);\n    }\n\n    function estimateReinvestReward() external override view returns (uint) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards < MIN_TOKENS_TO_REINVEST) {\n            return 0;\n        }\n        return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n\n    /**\n     * @notice Reward token balance that can be reinvested\n     * @dev Staking rewards accurue to contract on each deposit/withdrawal\n     * @return Unclaimed rewards, plus contract balance\n     */\n    function checkReward() public override view returns (uint) {\n        uint pendingReward = stakingContract.pendingBamboo(PID, address(this));\n        uint contractBalance = rewardToken.balanceOf(address(this));\n        return pendingReward.add(contractBalance);\n    }\n\n    function getDeployedBalance() external override view returns (uint) {\n        (uint amount,) = stakingContract.userInfo(PID, address(this));\n        return amount;\n    }\n\n    /**\n     * @notice Reinvest rewards from staking contract to deposit tokens\n     * @dev This private function does not require mininmum tokens to be met\n     * @dev Reward should go to tx.origin\n     * @param amount reward tokens\n     * @return deposit tokens reinvested\n     */\n    function _reinvest(uint amount) private returns (uint) {\n        stakingContract.deposit(PID, 0);\n\n        uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n        if (adminFee > 0) {\n            require(rewardToken.transfer(feeCollector, adminFee), \"Strategy::_reinvest, admin fee transfer failed\");\n        }\n\n        uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n        if (reinvestFee > 0) {\n            require(rewardToken.transfer(tx.origin, reinvestFee), \"Strategy::_reinvest, reinvest reward transfer failed\");\n        }\n\n        uint depositTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n        _stakeDepositTokens(depositTokenAmount);\n        return depositTokenAmount;\n    }\n\n    /**\n     * @notice Stakes deposit tokens in Staking Contract\n     * @param amount deposit tokens to stake\n     */\n    function _stakeDepositTokens(uint amount) private {\n        require(amount > 0, \"Strategy::_stakeDepositTokens, amount too low\");\n        stakingContract.deposit(PID, amount);\n    }\n\n    /**\n     * @notice Withdraws deposit tokens from Staking Contract\n     * @dev Reward tokens are automatically collected\n     * @dev Reward tokens are not automatically reinvested\n     * @param amount deposit tokens to remove\n     */\n    function _withdrawDepositTokens(uint amount) private {\n        require(amount > 0, \"Strategy::_withdrawDepositTokens, amount too low\");\n        stakingContract.withdraw(PID, amount);\n    }\n\n    /**\n     * @notice Converts entire reward token balance to deposit tokens\n     * @dev Always converts through router; there are no price checks enabled\n     * @return deposit tokens received\n     */\n    function _convertRewardTokensToDepositTokens(uint amount) private returns (uint) {\n        uint amountIn = amount.div(2);\n        require(amountIn > 0, \"amount too low\");\n\n        // swap to token0\n        address token0 = IPair(address(depositToken)).token0();\n        address[] memory path0 = new address[](2);\n        path0[0] = address(rewardToken);\n        path0[1] = token0;\n\n        uint amountOutToken0 = amountIn;\n        if (path0[0] != path0[1]) {\n            uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n            amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n            router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n        }\n\n        // swap to token1\n        address token1 = IPair(address(depositToken)).token1();\n        address[] memory path1 = new address[](2);\n        path1[0] = path0[0];\n        path1[1] = token1;\n\n        uint amountOutToken1 = amountIn;\n        if (path1[0] != path1[1]) {\n            uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n            amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n            router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n        }\n\n        (,,uint liquidity) = router.addLiquidity(\n            path0[1], path1[1],\n            amountOutToken0, amountOutToken1,\n            0, 0,\n            address(this),\n            block.timestamp\n        );\n\n        return liquidity;\n    }\n\n    /**\n     * @notice Update reinvest minimum threshold for external callers\n     * @param newValue min threshold in wei\n     */\n    function updateMinTokensToReinvest(uint newValue) external onlyManager {\n        emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n        MIN_TOKENS_TO_REINVEST = newValue;\n    }\n\n    /**\n     * @notice Update admin fee\n     * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n     * @param newValue specified in BIPS\n     */\n    function updateAdminFee(uint newValue) external onlyManager {\n        require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n        emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n        ADMIN_FEE_BIPS = newValue;\n    }\n\n    /**\n     * @notice Update reinvest reward\n     * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n     * @param newValue specified in BIPS\n     */\n    function updateReinvestReward(uint newValue) external onlyManager {\n        require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n        emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n        REINVEST_REWARD_BIPS = newValue;\n    }\n\n    function rescueDeployedFunds() external override onlyManagerOrVault {\n        stakingContract.emergencyWithdraw(PID);\n    }\n}"
    },
    "contracts/interfaces/IBambooChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IBambooChef {\n    function bamboo() external view returns (address);\n    function bambooPerBlock() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function add(uint256 _allocPoint, address _lpToken, bool _withUpdate) external;\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n    function setMigrator(address _migrator) external;\n    function migrate(uint256 _pid) external;\n    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n    function pendingBamboo(uint256 _pid, address _user) external view returns (uint256);\n    function massUpdatePools() external;\n    function updatePool(uint256 _pid) external;\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function dev(address _devaddr) external;\n    function poolInfo(uint pid) external view returns (\n        address lpToken,\n        uint allocPoint,\n        uint lastRewardBlock,\n        uint accSushiPerShare\n    );\n    function userInfo(uint pid, address user) external view returns (\n        uint256 amount,\n        uint256 rewardDebt\n    );\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}