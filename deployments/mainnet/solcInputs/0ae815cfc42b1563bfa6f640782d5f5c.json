{
  "language": "Solidity",
  "sources": {
    "contracts/BambooStrategyForLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IBambooChef.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract BambooStrategyForLP is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IBambooChef public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IBambooChef(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_depositToken).token0();\n    address _token1 = IPair(_depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Set approvals for tokens\n   * @param tokensToApprove tokens to approve\n   * @param approvalAmounts approval amounts\n   * @param spenders address allowed to spend tokens\n   */\n  function tokenAllow(\n      address[] memory tokensToApprove, \n      uint256[] memory approvalAmounts, \n      address[] memory spenders\n  ) external onlyOwner {\n    require(\n      tokensToApprove.length == approvalAmounts.length\n      && tokensToApprove.length == spenders.length\n    , \"not same length\");\n    for(uint i = 0; i < tokensToApprove.length; i++) {\n      IERC20 token = IERC20(tokensToApprove[i]);\n      uint allowance = token.allowance(address(this), spenders[i]);\n      if (\n        allowance != approvalAmounts[i] &&\n        (allowance != uint256(-1) || approvalAmounts[i] == 0)\n      ) {\n        require(token.approve(spenders[i], approvalAmounts[i]), \"approve failed\");\n      }\n    }\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingBamboo(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[1], path1[1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/YakERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\n\nabstract contract YakERC20 {\n    using SafeMath for uint256;\n\n    string public name = \"Yield Yak\";\n    string public symbol = \"YRT\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n  \n    mapping (address => mapping (address => uint256)) internal allowances;\n    mapping (address => uint256) internal balances;\n\n    /// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// keccak256(\"1\");\n    bytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    mapping(address => uint) public nonces;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {}\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * It is recommended to use increaseAllowance and decreaseAllowance instead\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowances[src][spender];\n\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = spenderAllowance.sub(amount, \"transferFrom: transfer amount exceeds allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n\n    /**\n     * @notice Approval implementation\n     * @param owner The address of the account which owns tokens\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"_approve::owner zero address\");\n        require(spender != address(0), \"_approve::spender zero address\");\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Transfer implementation\n     * @param from The address of the account which owns tokens\n     * @param to The address of the account which is receiving tokens\n     * @param value The number of tokens that are being transferred\n     */\n    function _transferTokens(address from, address to, uint256 value) internal {\n        require(to != address(0), \"_transferTokens: cannot transfer to the zero address\");\n\n        balances[from] = balances[from].sub(value, \"_transferTokens: transfer exceeds from balance\");\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balances[from] = balances[from].sub(value, \"_burn: burn amount exceeds from balance\");\n        totalSupply = totalSupply.sub(value, \"_burn: burn amount exceeds total supply\");\n        emit Transfer(from, address(0), value);\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spender\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param value The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"permit::expired\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @notice Recovers address from signed data and validates the signature\n     * @param signer Address that signed the data\n     * @param encodeData Data signed by the address\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"Arch::validateSig: invalid signature\");\n    }\n\n    /**\n     * @notice EIP-712 Domain separator\n     * @return Separator\n     */\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                VERSION_HASH,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Current id of the chain where this contract is deployed\n     * @return Chain id\n     */\n    function _getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/interfaces/IBambooChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IBambooChef {\n    function bamboo() external view returns (address);\n    function bambooPerBlock() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function add(uint256 _allocPoint, address _lpToken, bool _withUpdate) external;\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n    function setMigrator(address _migrator) external;\n    function migrate(uint256 _pid) external;\n    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n    function pendingBamboo(uint256 _pid, address _user) external view returns (uint256);\n    function massUpdatePools() external;\n    function updatePool(uint256 _pid) external;\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function dev(address _devaddr) external;\n    function poolInfo(uint pid) external view returns (\n        address lpToken,\n        uint allocPoint,\n        uint lastRewardBlock,\n        uint accSushiPerShare\n    );\n    function userInfo(uint pid, address user) external view returns (\n        uint256 amount,\n        uint256 rewardDebt\n    );\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n}"
    },
    "contracts/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IRouter {\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(address token, uint amountTokenDesired, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountAVAX);\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/interfaces/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\n\ninterface IPair is IERC20 {\n    function token0() external pure returns (address);\n    function token1() external pure returns (address);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"
    },
    "contracts/lib/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"
    },
    "contracts/YakVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/Ownable.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./YakStrategy.sol\";\n\n/**\n * @notice YakVault is a managed vault for `deposit tokens` that accepts deposits in the form of `deposit tokens` OR `strategy tokens`.\n * @dev DRAFT\n */\ncontract YakVault is YakERC20, Ownable {\n    using SafeMath for uint;\n\n    /// @notice Vault version number\n    string public constant version = \"0.0.1\";\n\n    /// @notice Deposit token that the vault manages\n    IERC20 public depositToken;\n\n    /// @notice Active strategy (where deposits are sent by default)\n    address public activeStrategy;\n\n    /// @notice Supported deposit tokens (Yak Receipt Tokens, usually)\n    mapping(address => bool) public supportedDepositTokens;\n\n    /// @notice Supported strategies\n    address[] public supportedStrategies;\n\n    event Deposit(address account, address token, uint amount);\n    event AddStrategy(address indexed strategy);\n    event RemoveStrategy(address indexed strategy);\n    event SetActiveStrategy(address indexed strategy);\n\n    constructor (\n        string memory _name,\n        address _depositToken\n    ) {\n        name = _name;\n        depositToken = IERC20(_depositToken);\n\n        supportedDepositTokens[_depositToken] = true;\n    }\n\n    /**\n     * @notice Deposit to currently active strategy\n     * @dev Vaults may allow multiple types of tokens to be deposited\n     * @dev By default, Vaults send new deposits to the active strategy\n     * @param token address\n     * @param amount amount\n     */\n    function deposit(address token, uint amount) external {\n        require(supportedDepositTokens[token], \"YakVault::deposit, token not supported\");\n        uint balanceBefore = IERC20(token).balanceOf(address(this));\n        require(IERC20(token).transferFrom(msg.sender, address(this), amount), \"YakVault::deposit, failed\");\n        uint balanceAfter = IERC20(token).balanceOf(address(this));\n        uint confirmedAmount = balanceAfter.sub(balanceBefore);\n        require(confirmedAmount > 0, \"YakVault::deposit, amount too low\");\n        if (token == address(depositToken)) {\n            YakStrategy(activeStrategy).deposit(confirmedAmount);\n        }\n        // todo - mint\n        _deposit(msg.sender, token, amount);\n    }\n\n    function depositWithPermit(address token, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        // todo\n        IERC20(token).permit(msg.sender, address(this), amount, deadline, v, r, s);\n        _deposit(msg.sender, token, amount);\n    }\n\n    function depositFor(address account, address token, uint amount) external {\n        // todo\n        _deposit(account, token, amount);\n    }\n\n    function _deposit(address account, address token, uint amount) private {\n        // todo\n        emit Deposit(account, token, amount);\n    }\n\n    /**\n     * @notice Withdraw from strategies\n     * @param amount receipt tokens\n     */\n    function withdraw(uint amount) external {\n        uint remainingDebt = getDepositTokensForShares(amount);\n        require(remainingDebt > 0, \"YakVault::withdraw, amount too low\");\n        // todo: manage withdraw\n        // todo: event\n    }\n\n    function _revokeApproval(address token, address spender) internal {\n        require(IERC20(token).approve(spender, 0), \"YakVault::revokeApproval\");\n    }\n\n    /**\n     * @notice Set an active strategy\n     * @param strategy address for new strategy\n     */\n    function setActiveStrategy(address strategy) public onlyOwner {\n        require(supportedDepositTokens[strategy], \"YakVault::setActiveStrategy, not found\");\n        require(depositToken.approve(strategy, uint(-1)));\n        _revokeApproval(address(depositToken), strategy);\n        activeStrategy = strategy;\n        emit SetActiveStrategy(strategy);\n    }\n\n    /**\n     * @notice Add a supported strategy and allow deposits\n     * @dev Makes light checks for compatible deposit tokens\n     */\n    function addStrategy(address strategy) public onlyOwner {\n        require(supportedDepositTokens[strategy] == false, \"YakVault::addStrategy, already supported\");\n        require(depositToken == YakStrategy(strategy).depositToken(), \"YakVault::addStrategy, not compatible\");\n        supportedDepositTokens[strategy] = true;\n        supportedStrategies.push(strategy);\n        emit AddStrategy(strategy);\n    }\n\n    /**\n     * @notice Remove a supported strategy and revoke approval\n     */\n    function removeStrategy(address strategy) public onlyOwner {\n        require(strategy != activeStrategy, \"YakVault::removeStrategy, cannot remove activeStrategy\");\n        require(strategy != address(depositToken), \"YakVault::removeStrategy, cannot remove deposit token\");\n        require(supportedDepositTokens[strategy] == true, \"YakVault::removeStrategy, not supported\");\n        _revokeApproval(address(depositToken), strategy);\n        supportedDepositTokens[strategy] = false;\n        // todo: update array\n        emit RemoveStrategy(strategy);\n    }\n\n    function withdrawFromStrategy(address strategy, uint amount) public onlyOwner {\n        // todo - conversion rate\n        uint balanceBefore = depositToken.balanceOf(address(this));\n        YakStrategy(strategy).withdraw(amount); // receipt token amount\n        uint balanceAfter = depositToken.balanceOf(address(this));\n        require(balanceAfter > balanceBefore, \"YakVault::withdrawFromStrategy\");\n        // todo - emit sync\n    }\n\n    function depositToStrategy(address strategy, uint amount) public onlyOwner {\n        // todo\n        // todo - approve\n        // depositToken.approve(strategy, amount);\n        YakStrategy(strategy).deposit(amount); // deposit token amount\n        // todo - emit sync\n    }\n\n    /**\n     * @notice Count deposit tokens deployed across supported strategies\n     * @dev Does not include deprecated strategies\n     */\n    function estimateDeployedBalances() public view returns (uint) {\n        uint deployedFunds = 0;\n        for (uint i = 0; i < supportedStrategies.length; i++) {\n            // todo fallback for old version to totalDeposits\n            uint deployedInStrategy = YakStrategy(supportedStrategies[i]).estimateDeployedBalance();\n            deployedFunds = deployedFunds.add(deployedInStrategy);\n        }\n        return deployedFunds;\n    }\n\n    function getDepositTokensForShares(uint amount) public view returns (uint) {\n        // todo\n    }\n\n    function getSharesForDepositTokens(uint amount) public view returns (uint) {\n        // todo\n    }\n}"
    },
    "contracts/YakStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/Ownable.sol\";\nimport \"./lib/Permissioned.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./YakERC20.sol\";\n\n/**\n * @notice YakStrategy should be inherited by new strategies\n */\nabstract contract YakStrategy is YakERC20, Ownable, Permissioned {\n    using SafeMath for uint;\n\n    uint public totalDeposits;\n\n    IERC20 public depositToken;\n    IERC20 public rewardToken;\n    address public devAddr;\n\n    uint public MIN_TOKENS_TO_REINVEST;\n    uint public MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST;\n    bool public DEPOSITS_ENABLED;\n\n    uint public REINVEST_REWARD_BIPS;\n    uint public ADMIN_FEE_BIPS;\n    uint public DEV_FEE_BIPS;\n\n    uint constant internal BIPS_DIVISOR = 10000;\n    uint constant internal MAX_UINT = uint(-1);\n\n    event Deposit(address indexed account, uint amount);\n    event Withdraw(address indexed account, uint amount);\n    event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n    event Recovered(address token, uint amount);\n    event UpdateAdminFee(uint oldValue, uint newValue);\n    event UpdateDevFee(uint oldValue, uint newValue);\n    event UpdateReinvestReward(uint oldValue, uint newValue);\n    event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n    event UpdateMaxTokensToDepositWithoutReinvest(uint oldValue, uint newValue);\n    event UpdateDevAddr(address oldValue, address newValue);\n    event DepositsEnabled(bool newValue);\n\n    /**\n     * @notice Throws if called by smart contract\n     */\n    modifier onlyEOA() {\n        require(tx.origin == msg.sender, \"YakStrategy::onlyEOA\");\n        _;\n    }\n\n    /**\n     * @notice Approve tokens for use in Strategy\n     * @dev Should use modifier `onlyOwner` to avoid griefing\n     */\n    function setAllowances() public virtual;\n\n    /**\n     * @notice Revoke token allowance\n     * @param token address\n     * @param spender address\n     */\n    function revokeAllowance(address token, address spender) external onlyOwner {\n        require(IERC20(token).approve(spender, 0));\n    }\n\n    /**\n     * @notice Deposit and deploy deposits tokens to the strategy\n     * @dev Must mint receipt tokens to `msg.sender`\n     * @param amount deposit tokens\n     */\n    function deposit(uint amount) external virtual;\n\n    /**\n    * @notice Deposit using Permit\n    * @dev Should revert for tokens without Permit\n    * @param amount Amount of tokens to deposit\n    * @param deadline The time at which to expire the signature\n    * @param v The recovery byte of the signature\n    * @param r Half of the ECDSA signature pair\n    * @param s Half of the ECDSA signature pair\n    */\n    function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external virtual;\n\n    /**\n     * @notice Deposit on behalf of another account\n     * @dev Must mint receipt tokens to `account`\n     * @param account address to receive receipt tokens\n     * @param amount deposit tokens\n     */\n    function depositFor(address account, uint amount) external virtual;\n\n    /**\n     * @notice Redeem receipt tokens for deposit tokens\n     * @param amount receipt tokens\n     */\n    function withdraw(uint amount) external virtual;\n\n    /**\n     * @notice Reinvest reward tokens into deposit tokens\n     */\n    function reinvest() external virtual;\n\n    /**\n     * @notice Estimate reinvest reward\n     * @return reward tokens\n     */\n    function estimateReinvestReward() external view returns (uint) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n            return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Reward tokens avialable to strategy, including balance\n     * @return reward tokens\n     */\n    function checkReward() public virtual view returns (uint);\n\n    /**\n     * @notice Estimated deposit token balance deployed by strategy, excluding balance\n     * @return deposit tokens\n     */\n    function estimateDeployedBalance() external virtual view returns (uint);\n\n    /**\n     * @notice Rescue all available deployed deposit tokens back to Strategy\n     * @param minReturnAmountAccepted min deposit tokens to receive\n     * @param disableDeposits bool\n     */\n    function rescueDeployedFunds(uint minReturnAmountAccepted, bool disableDeposits) external virtual;\n\n    /**\n     * @notice Calculate receipt tokens for a given amount of deposit tokens\n     * @dev If contract is empty, use 1:1 ratio\n     * @dev Could return zero shares for very low amounts of deposit tokens\n     * @param amount deposit tokens\n     * @return receipt tokens\n     */\n    function getSharesForDepositTokens(uint amount) public view returns (uint) {\n        if (totalSupply.mul(totalDeposits) == 0) {\n            return amount;\n        }\n        return amount.mul(totalSupply).div(totalDeposits);\n    }\n\n    /**\n     * @notice Calculate deposit tokens for a given amount of receipt tokens\n     * @param amount receipt tokens\n     * @return deposit tokens\n     */\n    function getDepositTokensForShares(uint amount) public view returns (uint) {\n        if (totalSupply.mul(totalDeposits) == 0) {\n            return 0;\n        }\n        return amount.mul(totalDeposits).div(totalSupply);\n    }\n\n    /**\n     * @notice Update reinvest min threshold\n     * @param newValue threshold\n     */\n    function updateMinTokensToReinvest(uint newValue) public onlyOwner {\n        emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n        MIN_TOKENS_TO_REINVEST = newValue;\n    }\n\n    /**\n     * @notice Update reinvest max threshold before a deposit\n     * @param newValue threshold\n     */\n    function updateMaxTokensToDepositWithoutReinvest(uint newValue) public onlyOwner {\n        emit UpdateMaxTokensToDepositWithoutReinvest(MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST, newValue);\n        MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST = newValue;\n    }\n\n    /**\n     * @notice Update developer fee\n     * @param newValue fee in BIPS\n     */\n    function updateDevFee(uint newValue) public onlyOwner {\n        require(newValue.add(ADMIN_FEE_BIPS).add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR);\n        emit UpdateDevFee(DEV_FEE_BIPS, newValue);\n        DEV_FEE_BIPS = newValue;\n    }\n\n    /**\n     * @notice Update admin fee\n     * @param newValue fee in BIPS\n     */\n    function updateAdminFee(uint newValue) public onlyOwner {\n        require(newValue.add(DEV_FEE_BIPS).add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR);\n        emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n        ADMIN_FEE_BIPS = newValue;\n    }\n\n    /**\n     * @notice Update reinvest reward\n     * @param newValue fee in BIPS\n     */\n    function updateReinvestReward(uint newValue) public onlyOwner {\n        require(newValue.add(ADMIN_FEE_BIPS).add(DEV_FEE_BIPS) <= BIPS_DIVISOR);\n        emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n        REINVEST_REWARD_BIPS = newValue;\n    }\n\n    /**\n     * @notice Enable/disable deposits\n     * @param newValue bool\n     */\n    function updateDepositsEnabled(bool newValue) public onlyOwner {\n        require(DEPOSITS_ENABLED != newValue);\n        DEPOSITS_ENABLED = newValue;\n        emit DepositsEnabled(newValue);\n    }\n\n    /**\n     * @notice Update devAddr\n     * @param newValue address\n     */\n    function updateDevAddr(address newValue) public {\n        require(msg.sender == devAddr);\n        emit UpdateDevAddr(devAddr, newValue);\n        devAddr = newValue;\n    }\n\n    /**\n     * @notice Recover ERC20 from contract\n     * @param tokenAddress token address\n     * @param tokenAmount amount to recover\n     */\n    function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n        require(tokenAmount > 0);\n        require(IERC20(tokenAddress).transfer(msg.sender, tokenAmount));\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Recover AVAX from contract\n     * @param amount amount\n     */\n    function recoverAVAX(uint amount) external onlyOwner {\n        require(amount > 0);\n        msg.sender.transfer(amount);\n        emit Recovered(address(0), amount);\n    }\n}"
    },
    "contracts/lib/Permissioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./Ownable.sol\";\nimport \"./SafeMath.sol\";\n\nabstract contract Permissioned is Ownable {\n    using SafeMath for uint;\n\n    uint public numberOfAllowedDepositors;\n    mapping(address => bool) public allowedDepositors;\n\n    event AllowDepositor(address indexed account);\n    event RemoveDepositor(address indexed account);\n\n    modifier onlyAllowedDeposits() {\n        if (numberOfAllowedDepositors > 0) {\n            require(allowedDepositors[msg.sender] == true, \"Permissioned::onlyAllowedDeposits, not allowed\");\n        }\n        _;\n    }\n\n    /**\n     * @notice Add an allowed depositor\n     * @param depositor address\n     */\n    function allowDepositor(address depositor) external onlyOwner {\n        require(allowedDepositors[depositor] == false, \"Permissioned::allowDepositor\");\n        allowedDepositors[depositor] = true;\n        numberOfAllowedDepositors = numberOfAllowedDepositors.add(1);\n        emit AllowDepositor(depositor);\n    }\n\n    /**\n     * @notice Remove an allowed depositor\n     * @param depositor address\n     */\n    function removeDepositor(address depositor) external onlyOwner {\n        require(numberOfAllowedDepositors > 0, \"Permissioned::removeDepositor, no allowed depositors\");\n        require(allowedDepositors[depositor] == true, \"Permissioned::removeDepositor, not allowed\");\n        allowedDepositors[depositor] = false;\n        numberOfAllowedDepositors = numberOfAllowedDepositors.sub(1);\n        emit RemoveDepositor(depositor);\n    }\n}"
    },
    "contracts/strategies/PenguinStrategyForLPb.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../YakStrategy.sol\";\nimport \"../interfaces/IPenguinChef.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\n\n/**\n * @notice Token1 strategy for Penguin Igloos\n */\ncontract PenguinStrategyForLPb is YakStrategy {\n  using SafeMath for uint;\n\n  IRouter public router;\n  IPenguinChef public stakingContract;\n  address private constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n  uint public PID;\n\n  constructor(\n    string memory _name,\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    address _timelock,\n    uint _pid,\n    uint _minTokensToReinvest,\n    uint _adminFeeBips,\n    uint _devFeeBips,\n    uint _reinvestRewardBips\n  ) {\n    name = _name;\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IPenguinChef(_stakingContract);\n    router = IRouter(_router);\n    PID = _pid;\n    devAddr = msg.sender;\n\n    setAllowances();\n    updateMinTokensToReinvest(_minTokensToReinvest);\n    updateAdminFee(_adminFeeBips);\n    updateDevFee(_devFeeBips);\n    updateReinvestReward(_reinvestRewardBips);\n    updateDepositsEnabled(true);\n    transferOwnership(_timelock);\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public override onlyOwner {\n    depositToken.approve(address(stakingContract), MAX_UINT);\n    rewardToken.approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token0()).approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token1()).approve(address(router), MAX_UINT);\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external override {\n    _deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(msg.sender, amount);\n  }\n\n  function depositFor(address account, uint amount) external override {\n      _deposit(account, amount);\n  }\n\n  function _deposit(address account, uint amount) internal {\n    require(DEPOSITS_ENABLED == true, \"PenguinStrategyForLP::_deposit\");\n    if (MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST > 0) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards > MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST) {\n            _reinvest(unclaimedRewards);\n        }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount));\n    _stakeDepositTokens(amount);\n    _mint(account, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(account, amount);\n  }\n\n  function withdraw(uint amount) external override {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      (,,,, uint withdrawFeeBP) = stakingContract.poolInfo(PID);\n      uint withdrawFee = depositTokenAmount.mul(withdrawFeeBP).div(BIPS_DIVISOR);\n      require(depositToken.transfer(msg.sender, depositTokenAmount.sub(withdrawFee)), \"PenguinStrategyForLP::withdraw\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  function _withdrawDepositTokens(uint amount) private {\n    require(amount > 0, \"PenguinStrategyForLP::_withdrawDepositTokens\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  function reinvest() external override onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"PenguinStrategyForLP::reinvest\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n    * @notice Reinvest rewards from staking contract to deposit tokens\n    * @dev Reverts if the expected amount of tokens are not returned from `stakingContract`\n    * @param amount deposit tokens to reinvest\n    */\n  function _reinvest(uint amount) private {\n    stakingContract.deposit(PID, 0);\n\n    uint devFee = amount.mul(DEV_FEE_BIPS).div(BIPS_DIVISOR);\n    if (devFee > 0) {\n      require(rewardToken.transfer(devAddr, devFee), \"PenguinStrategyForLP::_reinvest, dev\");\n    }\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"PenguinStrategyForLP::_reinvest, admin\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"PenguinStrategyForLP::_reinvest, reward\");\n    }\n\n    uint depositTokenAmount = _convertRewardTokensToDepositTokens(\n      amount.sub(devFee).sub(adminFee).sub(reinvestFee)\n    );\n\n    _stakeDepositTokens(depositTokenAmount);\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n    \n  function _stakeDepositTokens(uint amount) private {\n    require(amount > 0, \"PenguinStrategyForLP::_stakeDepositTokens\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  function checkReward() public override view returns (uint) {\n    uint pendingReward = stakingContract.pendingPEFI(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n    * @notice Converts reward tokens to deposit tokens\n    * @dev Always converts through router; there are no price checks enabled\n    * @return deposit tokens received\n    */\n  function _convertRewardTokensToDepositTokens(uint amount) private returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"PenguinStrategyForLP::_convertRewardTokensToDepositTokens\");\n\n    // swap to token0\n    uint path0Length = 2;\n    address[] memory path0 = new address[](path0Length);\n    path0[0] = address(rewardToken);\n    path0[1] = IPair(address(depositToken)).token0();\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0Length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    uint path1Length = 3;\n    address[] memory path1 = new address[](path1Length);\n    path1[0] = path0[0];\n    path1[1] = WAVAX;\n    path1[2] = IPair(address(depositToken)).token1();\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1Length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0Length - 1], path1[path1Length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Estimate recoverable balance after withdraw fee\n   * @return deposit tokens after withdraw fee\n   */\n  function estimateDeployedBalance() external override view returns (uint) {\n    (uint depositBalance, ) = stakingContract.userInfo(PID, address(this));\n    (,,,, uint withdrawFeeBP) = stakingContract.poolInfo(PID);\n    uint withdrawFee = depositBalance.mul(withdrawFeeBP).div(BIPS_DIVISOR);\n    return depositBalance.sub(withdrawFee);\n  }\n\n  function rescueDeployedFunds(uint minReturnAmountAccepted, bool disableDeposits) external override onlyOwner {\n    uint balanceBefore = depositToken.balanceOf(address(this));\n    stakingContract.emergencyWithdraw(PID);\n    uint balanceAfter = depositToken.balanceOf(address(this));\n    require(balanceAfter.sub(balanceBefore) >= minReturnAmountAccepted, \"PenguinStrategyForLP::rescueDeployedFunds\");\n    totalDeposits = balanceAfter;\n    emit Reinvest(totalDeposits, totalSupply);\n    if (DEPOSITS_ENABLED == true && disableDeposits == true) {\n      updateDepositsEnabled(false);\n    }\n  }\n}"
    },
    "contracts/interfaces/IPenguinChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IPenguinChef {\n    function pefi() external view returns (address);\n    function pefiPerBlock() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function add(uint256 _allocPoint, address _lpToken, uint16 _withdrawFeeBP, bool _withUpdate) external;\n    function set(uint256 _pid, uint256 _allocPoint, uint16 _withdrawFeeBP, bool _withUpdate) external;\n    function setMigrator(address _migrator) external;\n    function migrate(uint256 _pid) external;\n    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n    function pendingPEFI(uint256 _pid, address _user) external view returns (uint256);\n    function massUpdatePools() external;\n    function updatePool(uint256 _pid) external;\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function dev(address _devaddr) external;\n    function poolInfo(uint pid) external view returns (\n        address lpToken,\n        uint allocPoint,\n        uint lastRewardBlock,\n        uint accPEFIPerShare,\n        uint16 withdrawFeeBP\n    );\n    function userInfo(uint pid, address user) external view returns (\n        uint256 amount,\n        uint256 rewardDebt\n    );\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n}"
    },
    "contracts/SuStrategyV3.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/ISudoSu.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract SuStrategyV3 is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  ISudoSu public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = ISudoSu(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_depositToken).token0();\n    address _token1 = IPair(_depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Set approvals for tokens\n   * @param tokensToApprove tokens to approve\n   * @param approvalAmounts approval amounts\n   * @param spenders address allowed to spend tokens\n   */\n  function tokenAllow(\n      address[] memory tokensToApprove, \n      uint256[] memory approvalAmounts, \n      address[] memory spenders\n  ) external onlyOwner {\n    require(\n      tokensToApprove.length == approvalAmounts.length\n      && tokensToApprove.length == spenders.length\n    , \"not same length\");\n    for(uint i = 0; i < tokensToApprove.length; i++) {\n      IERC20 token = IERC20(tokensToApprove[i]);\n      uint allowance = token.allowance(address(this), spenders[i]);\n      if (\n        allowance != approvalAmounts[i] &&\n        (allowance != uint256(-1) || approvalAmounts[i] == 0)\n      ) {\n        require(token.approve(spenders[i], approvalAmounts[i]), \"approve failed\");\n      }\n    }\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingCom(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n  \n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0.length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1.length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0.length - 1], path1[path1.length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/interfaces/ISudoSu.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface ISudoSu {\n    function poolLength() external view returns (uint256);\n    function setComPerBlock(uint256 _newPerBlock) external;\n    function add(uint256 _allocPoint, address _lpToken, bool _withUpdate) external;\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n    function setMigrator(address _migrator) external;\n    function migrate(uint256 _pid) external;\n    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n    function pendingCom(uint256 _pid, address _user) external view returns (uint256);\n    function massUpdatePools() external;\n    function updatePool(uint256 _pid) external;\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function dev(address _devaddr) external;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n}"
    },
    "contracts/SuStrategyV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SnowballERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/ISudoSu.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract SuStrategyV2 is SnowballERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public lpToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  ISudoSu public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n\n  event Deposit(address account, uint amount);\n  event Withdraw(address account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n\n  constructor(\n    address _lpToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    lpToken = IPair(_lpToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = ISudoSu(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_lpToken).token0();\n    address _token1 = IPair(_lpToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    IERC20(_rewardToken).approve(_router, uint(-1));\n    IERC20(_token0).approve(_router, uint(-1));\n    IERC20(_token1).approve(_router, uint(-1));\n    IPair(_lpToken).approve(_stakingContract, uint(-1));\n\n    name = string(\n      abi.encodePacked(\n        \"Snowball: \",\n        lpToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    lpToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    require(lpToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeLpTokens(amount);\n    _mint(msg.sender, getSharesForLPTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming Snowball tokens\n   * @param amount Amount of Snowball tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint lpTokenAmount = getLPTokensForShares(amount);\n    if (lpTokenAmount > 0) {\n      _withdrawLpTokens(lpTokenAmount);\n      require(lpToken.transfer(msg.sender, lpTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(lpTokenAmount);\n      emit Withdraw(msg.sender, lpTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate Snowball tokens for a given amount of LP tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of LP tokens\n   * @param amount LP tokens\n   * @return Snowball tokens\n   */\n  function getSharesForLPTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate LP tokens for a given amount of Snowball tokens\n   * @param amount Snowball tokens\n   * @return LP tokens\n   */\n  function getLPTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingCom(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to LP tokens\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = unclaimedRewards.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToLpTokens(unclaimedRewards.sub(adminFee).sub(reinvestFee));\n    _stakeLpTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to LP tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return LP tokens received\n   */\n  function _convertRewardTokensToLpTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[1], path1[1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes LP tokens in Staking Contract\n   * @param amount LP tokens to stake\n   */\n  function _stakeLpTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws LP tokens from Staking Contract\n   * @dev Rewards are not automatically collected from the Staking Contract\n   * @param amount LP tokens to remove;\n   */\n  function _withdrawLpTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/SnowballERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\n\nabstract contract SnowballERC20 {\n    using SafeMath for uint256;\n\n    string public name = \"Snowball\";\n    string public symbol = \"SNOW\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n  \n    mapping (address => mapping (address => uint256)) internal allowances;\n    mapping (address => uint256) internal balances;\n\n    /// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// keccak256(\"1\");\n    bytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    mapping(address => uint) public nonces;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {}\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * It is recommended to use increaseAllowance and decreaseAllowance instead\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowances[src][spender];\n\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = spenderAllowance.sub(amount, \"transferFrom: transfer amount exceeds allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n\n    /**\n     * @notice Approval implementation\n     * @param owner The address of the account which owns tokens\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"_approve::owner zero address\");\n        require(spender != address(0), \"_approve::spender zero address\");\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Transfer implementation\n     * @param from The address of the account which owns tokens\n     * @param to The address of the account which is receiving tokens\n     * @param value The number of tokens that are being transferred\n     */\n    function _transferTokens(address from, address to, uint256 value) internal {\n        require(to != address(0), \"_transferTokens: cannot transfer to the zero address\");\n\n        balances[from] = balances[from].sub(value, \"_transferTokens: transfer exceeds from balance\");\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balances[from] = balances[from].sub(value, \"_burn: burn amount exceeds from balance\");\n        totalSupply = totalSupply.sub(value, \"_burn: burn amount exceeds total supply\");\n        emit Transfer(from, address(0), value);\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spender\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param value The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"permit::expired\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @notice Recovers address from signed data and validates the signature\n     * @param signer Address that signed the data\n     * @param encodeData Data signed by the address\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"Arch::validateSig: invalid signature\");\n    }\n\n    /**\n     * @notice EIP-712 Domain separator\n     * @return Separator\n     */\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                VERSION_HASH,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Current id of the chain where this contract is deployed\n     * @return Chain id\n     */\n    function _getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "contracts/strategies/PenguinStrategyForLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../YakStrategy.sol\";\nimport \"../interfaces/IPenguinChef.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\n\n/**\n * @notice Pool2 strategy for Penguin Igloos\n */\ncontract PenguinStrategyForLP is YakStrategy {\n  using SafeMath for uint;\n\n  IRouter public router;\n  IPenguinChef public stakingContract;\n\n  uint public PID;\n\n  constructor(\n    string memory _name,\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    address _timelock,\n    uint _pid,\n    uint _minTokensToReinvest,\n    uint _adminFeeBips,\n    uint _devFeeBips,\n    uint _reinvestRewardBips\n  ) {\n    name = _name;\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IPenguinChef(_stakingContract);\n    router = IRouter(_router);\n    PID = _pid;\n    devAddr = msg.sender;\n\n    setAllowances();\n    updateMinTokensToReinvest(_minTokensToReinvest);\n    updateAdminFee(_adminFeeBips);\n    updateDevFee(_devFeeBips);\n    updateReinvestReward(_reinvestRewardBips);\n    updateDepositsEnabled(true);\n    transferOwnership(_timelock);\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public override onlyOwner {\n    depositToken.approve(address(stakingContract), MAX_UINT);\n    rewardToken.approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token0()).approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token1()).approve(address(router), MAX_UINT);\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external override {\n    _deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(msg.sender, amount);\n  }\n\n  function depositFor(address account, uint amount) external override {\n      _deposit(account, amount);\n  }\n\n  function _deposit(address account, uint amount) internal {\n    require(DEPOSITS_ENABLED == true, \"PenguinStrategyForLP::_deposit\");\n    if (MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST > 0) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards > MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST) {\n            _reinvest(unclaimedRewards);\n        }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount));\n    _stakeDepositTokens(amount);\n    _mint(account, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(account, amount);\n  }\n\n  function withdraw(uint amount) external override {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      (,,,, uint withdrawFeeBP) = stakingContract.poolInfo(PID);\n      uint withdrawFee = depositTokenAmount.mul(withdrawFeeBP).div(BIPS_DIVISOR);\n      require(depositToken.transfer(msg.sender, depositTokenAmount.sub(withdrawFee)), \"PenguinStrategyForLP::withdraw\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  function _withdrawDepositTokens(uint amount) private {\n    require(amount > 0, \"PenguinStrategyForLP::_withdrawDepositTokens\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  function reinvest() external override onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"PenguinStrategyForLP::reinvest\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n    * @notice Reinvest rewards from staking contract to deposit tokens\n    * @dev Reverts if the expected amount of tokens are not returned from `stakingContract`\n    * @param amount deposit tokens to reinvest\n    */\n  function _reinvest(uint amount) private {\n    stakingContract.deposit(PID, 0);\n\n    uint devFee = amount.mul(DEV_FEE_BIPS).div(BIPS_DIVISOR);\n    if (devFee > 0) {\n      require(rewardToken.transfer(devAddr, devFee), \"PenguinStrategyForLP::_reinvest, dev\");\n    }\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"PenguinStrategyForLP::_reinvest, admin\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"PenguinStrategyForLP::_reinvest, reward\");\n    }\n\n    uint depositTokenAmount = _convertRewardTokensToDepositTokens(\n      amount.sub(devFee).sub(adminFee).sub(reinvestFee)\n    );\n\n    _stakeDepositTokens(depositTokenAmount);\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n    \n  function _stakeDepositTokens(uint amount) private {\n    require(amount > 0, \"PenguinStrategyForLP::_stakeDepositTokens\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  function checkReward() public override view returns (uint) {\n    uint pendingReward = stakingContract.pendingPEFI(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n    * @notice Converts reward tokens to deposit tokens\n    * @dev Always converts through router; there are no price checks enabled\n    * @return deposit tokens received\n    */\n  function _convertRewardTokensToDepositTokens(uint amount) private returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"PenguinStrategyForLP::_convertRewardTokensToDepositTokens\");\n\n    // swap to token0\n    uint path0Length = 2;\n    address[] memory path0 = new address[](path0Length);\n    path0[0] = address(rewardToken);\n    path0[1] = IPair(address(depositToken)).token0();\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0Length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    uint path1Length = 2;\n    address[] memory path1 = new address[](path1Length);\n    path1[0] = path0[0];\n    path1[1] = IPair(address(depositToken)).token1();\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1Length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0Length - 1], path1[path1Length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Estimate recoverable balance after withdraw fee\n   * @return deposit tokens after withdraw fee\n   */\n  function estimateDeployedBalance() external override view returns (uint) {\n    (uint depositBalance, ) = stakingContract.userInfo(PID, address(this));\n    (,,,, uint withdrawFeeBP) = stakingContract.poolInfo(PID);\n    uint withdrawFee = depositBalance.mul(withdrawFeeBP).div(BIPS_DIVISOR);\n    return depositBalance.sub(withdrawFee);\n  }\n\n  function rescueDeployedFunds(uint minReturnAmountAccepted, bool disableDeposits) external override onlyOwner {\n    uint balanceBefore = depositToken.balanceOf(address(this));\n    stakingContract.emergencyWithdraw(PID);\n    uint balanceAfter = depositToken.balanceOf(address(this));\n    require(balanceAfter.sub(balanceBefore) >= minReturnAmountAccepted, \"PenguinStrategyForLP::rescueDeployedFunds\");\n    totalDeposits = balanceAfter;\n    emit Reinvest(totalDeposits, totalSupply);\n    if (DEPOSITS_ENABLED == true && disableDeposits == true) {\n      updateDepositsEnabled(false);\n    }\n  }\n}"
    },
    "contracts/strategies/LydiaStrategyForLPb.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../YakStrategy.sol\";\nimport \"../interfaces/ILydiaChef.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\n\n/**\n * @notice Token1 strategy for Lydia Farms\n */\ncontract LydiaStrategyForLPb is YakStrategy {\n  using SafeMath for uint;\n\n  IRouter public router;\n  ILydiaChef public stakingContract;\n  address private constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n  uint public PID;\n\n  constructor(\n    string memory _name,\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    address _timelock,\n    uint _pid,\n    uint _minTokensToReinvest,\n    uint _adminFeeBips,\n    uint _devFeeBips,\n    uint _reinvestRewardBips\n  ) {\n    name = _name;\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = ILydiaChef(_stakingContract);\n    router = IRouter(_router);\n    PID = _pid;\n    devAddr = msg.sender;\n\n    setAllowances();\n    updateMinTokensToReinvest(_minTokensToReinvest);\n    updateAdminFee(_adminFeeBips);\n    updateDevFee(_devFeeBips);\n    updateReinvestReward(_reinvestRewardBips);\n    updateDepositsEnabled(true);\n    transferOwnership(_timelock);\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public override onlyOwner {\n    depositToken.approve(address(stakingContract), MAX_UINT);\n    rewardToken.approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token0()).approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token1()).approve(address(router), MAX_UINT);\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external override {\n    _deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(msg.sender, amount);\n  }\n\n  function depositFor(address account, uint amount) external override {\n      _deposit(account, amount);\n  }\n\n  function _deposit(address account, uint amount) internal {\n    require(DEPOSITS_ENABLED == true, \"LydiaStrategyForLP::_deposit\");\n    if (MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST > 0) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards > MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST) {\n            _reinvest(unclaimedRewards);\n        }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount));\n    _stakeDepositTokens(amount);\n    _mint(account, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(account, amount);\n  }\n\n  function withdraw(uint amount) external override {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"LydiaStrategyForLP::withdraw\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  function _withdrawDepositTokens(uint amount) private {\n    require(amount > 0, \"LydiaStrategyForLP::_withdrawDepositTokens\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  function reinvest() external override onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"LydiaStrategyForLP::reinvest\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n    * @notice Reinvest rewards from staking contract to deposit tokens\n    * @dev Reverts if the expected amount of tokens are not returned from `stakingContract`\n    * @param amount deposit tokens to reinvest\n    */\n  function _reinvest(uint amount) private {\n    stakingContract.deposit(PID, 0);\n\n    uint devFee = amount.mul(DEV_FEE_BIPS).div(BIPS_DIVISOR);\n    if (devFee > 0) {\n      require(rewardToken.transfer(devAddr, devFee), \"LydiaStrategyForLP::_reinvest, dev\");\n    }\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"LydiaStrategyForLP::_reinvest, admin\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"LydiaStrategyForLP::_reinvest, reward\");\n    }\n\n    uint depositTokenAmount = _convertRewardTokensToDepositTokens(\n      amount.sub(devFee).sub(adminFee).sub(reinvestFee)\n    );\n\n    _stakeDepositTokens(depositTokenAmount);\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n    \n  function _stakeDepositTokens(uint amount) private {\n    require(amount > 0, \"LydiaStrategyForLP::_stakeDepositTokens\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  function checkReward() public override view returns (uint) {\n    uint pendingReward = stakingContract.pendingLyd(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n    * @notice Converts reward tokens to deposit tokens\n    * @dev Always converts through router; there are no price checks enabled\n    * @return deposit tokens received\n    */\n  function _convertRewardTokensToDepositTokens(uint amount) private returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"LydiaStrategyForLP::_convertRewardTokensToDepositTokens\");\n\n    // swap to token0\n    uint path0Length = 2;\n    address[] memory path0 = new address[](path0Length);\n    path0[0] = address(rewardToken);\n    path0[1] = IPair(address(depositToken)).token0();\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0Length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    uint path1Length = 3;\n    address[] memory path1 = new address[](path1Length);\n    path1[0] = path0[0];\n    path1[1] = WAVAX;\n    path1[2] = IPair(address(depositToken)).token1();\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1Length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0Length - 1], path1[path1Length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Estimate recoverable balance\n   * @return deposit tokens\n   */\n  function estimateDeployedBalance() external override view returns (uint) {\n    (uint depositBalance, ) = stakingContract.userInfo(PID, address(this));\n    return depositBalance;\n  }\n\n  function rescueDeployedFunds(uint minReturnAmountAccepted, bool disableDeposits) external override onlyOwner {\n    uint balanceBefore = depositToken.balanceOf(address(this));\n    stakingContract.emergencyWithdraw(PID);\n    uint balanceAfter = depositToken.balanceOf(address(this));\n    require(balanceAfter.sub(balanceBefore) >= minReturnAmountAccepted, \"LydiaStrategyForLP::rescueDeployedFunds\");\n    totalDeposits = balanceAfter;\n    emit Reinvest(totalDeposits, totalSupply);\n    if (DEPOSITS_ENABLED == true && disableDeposits == true) {\n      updateDepositsEnabled(false);\n    }\n  }\n}"
    },
    "contracts/interfaces/ILydiaChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface ILydiaChef {\n    function lyd() external view returns (address);\n    function electrum() external view returns (address);\n    function lydPerSec() external view returns (uint256);\n    function totalAllocPoint() external view returns (uint256);\n    function startTimestamp() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function add(uint256 _allocPoint, address _lpToken, bool _withUpdate) external;\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n    function pendingLyd(uint256 _pid, address _user) external view returns (uint256);\n    function massUpdatePools() external;\n    function updatePool(uint256 _pid) external;\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function enterStaking(uint256 _amount) external;\n    function leaveStaking(uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function dev(address _devaddr) external;\n    function updateEmissionRate(uint256 _lydPerSec) external;\n    function poolInfo(uint pid) external view returns (\n        address lpToken,\n        uint allocPoint,\n        uint lastRewardTimestamp,\n        uint accLydPerShare\n    );\n    function userInfo(uint pid, address user) external view returns (\n        uint256 amount,\n        uint256 rewardDebt\n    );\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event SetDevAddress(address indexed user, address indexed newAddress);\n    event UpdateEmissionRate(address indexed user, uint256 _lydPerSec);\n}"
    },
    "contracts/strategies/LydiaStrategyForLPa.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../YakStrategy.sol\";\nimport \"../interfaces/ILydiaChef.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\n\n/**\n * @notice Token0 strategy for Lydia Farms\n */\ncontract LydiaStrategyForLPa is YakStrategy {\n  using SafeMath for uint;\n\n  IRouter public router;\n  ILydiaChef public stakingContract;\n  address private constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n  uint public PID;\n\n  constructor(\n    string memory _name,\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    address _timelock,\n    uint _pid,\n    uint _minTokensToReinvest,\n    uint _adminFeeBips,\n    uint _devFeeBips,\n    uint _reinvestRewardBips\n  ) {\n    name = _name;\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = ILydiaChef(_stakingContract);\n    router = IRouter(_router);\n    PID = _pid;\n    devAddr = msg.sender;\n\n    setAllowances();\n    updateMinTokensToReinvest(_minTokensToReinvest);\n    updateAdminFee(_adminFeeBips);\n    updateDevFee(_devFeeBips);\n    updateReinvestReward(_reinvestRewardBips);\n    updateDepositsEnabled(true);\n    transferOwnership(_timelock);\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public override onlyOwner {\n    depositToken.approve(address(stakingContract), MAX_UINT);\n    rewardToken.approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token0()).approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token1()).approve(address(router), MAX_UINT);\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external override {\n    _deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(msg.sender, amount);\n  }\n\n  function depositFor(address account, uint amount) external override {\n      _deposit(account, amount);\n  }\n\n  function _deposit(address account, uint amount) internal {\n    require(DEPOSITS_ENABLED == true, \"LydiaStrategyForLP::_deposit\");\n    if (MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST > 0) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards > MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST) {\n            _reinvest(unclaimedRewards);\n        }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount));\n    _stakeDepositTokens(amount);\n    _mint(account, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(account, amount);\n  }\n\n  function withdraw(uint amount) external override {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"LydiaStrategyForLP::withdraw\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  function _withdrawDepositTokens(uint amount) private {\n    require(amount > 0, \"LydiaStrategyForLP::_withdrawDepositTokens\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  function reinvest() external override onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"LydiaStrategyForLP::reinvest\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n    * @notice Reinvest rewards from staking contract to deposit tokens\n    * @dev Reverts if the expected amount of tokens are not returned from `stakingContract`\n    * @param amount deposit tokens to reinvest\n    */\n  function _reinvest(uint amount) private {\n    stakingContract.deposit(PID, 0);\n\n    uint devFee = amount.mul(DEV_FEE_BIPS).div(BIPS_DIVISOR);\n    if (devFee > 0) {\n      require(rewardToken.transfer(devAddr, devFee), \"LydiaStrategyForLP::_reinvest, dev\");\n    }\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"LydiaStrategyForLP::_reinvest, admin\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"LydiaStrategyForLP::_reinvest, reward\");\n    }\n\n    uint depositTokenAmount = _convertRewardTokensToDepositTokens(\n      amount.sub(devFee).sub(adminFee).sub(reinvestFee)\n    );\n\n    _stakeDepositTokens(depositTokenAmount);\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n    \n  function _stakeDepositTokens(uint amount) private {\n    require(amount > 0, \"LydiaStrategyForLP::_stakeDepositTokens\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  function checkReward() public override view returns (uint) {\n    uint pendingReward = stakingContract.pendingLyd(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n    * @notice Converts reward tokens to deposit tokens\n    * @dev Always converts through router; there are no price checks enabled\n    * @return deposit tokens received\n    */\n  function _convertRewardTokensToDepositTokens(uint amount) private returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"LydiaStrategyForLP::_convertRewardTokensToDepositTokens\");\n\n    // swap to token0\n    uint path0Length = 3;\n    address[] memory path0 = new address[](path0Length);\n    path0[0] = address(rewardToken);\n    path0[1] = WAVAX;\n    path0[2] = IPair(address(depositToken)).token0();\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0Length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    uint path1Length = 2;\n    address[] memory path1 = new address[](path1Length);\n    path1[0] = path0[0];\n    path1[1] = IPair(address(depositToken)).token1();\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1Length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0Length - 1], path1[path1Length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Estimate recoverable balance\n   * @return deposit tokens\n   */\n  function estimateDeployedBalance() external override view returns (uint) {\n    (uint depositBalance, ) = stakingContract.userInfo(PID, address(this));\n    return depositBalance;\n  }\n\n  function rescueDeployedFunds(uint minReturnAmountAccepted, bool disableDeposits) external override onlyOwner {\n    uint balanceBefore = depositToken.balanceOf(address(this));\n    stakingContract.emergencyWithdraw(PID);\n    uint balanceAfter = depositToken.balanceOf(address(this));\n    require(balanceAfter.sub(balanceBefore) >= minReturnAmountAccepted, \"LydiaStrategyForLP::rescueDeployedFunds\");\n    totalDeposits = balanceAfter;\n    emit Reinvest(totalDeposits, totalSupply);\n    if (DEPOSITS_ENABLED == true && disableDeposits == true) {\n      updateDepositsEnabled(false);\n    }\n  }\n}"
    },
    "contracts/strategies/LydiaStrategyForLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../YakStrategy.sol\";\nimport \"../interfaces/ILydiaChef.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\n\n/**\n * @notice Pool2 strategy for Lydia Farms\n */\ncontract LydiaStrategyForLP is YakStrategy {\n  using SafeMath for uint;\n\n  IRouter public router;\n  ILydiaChef public stakingContract;\n\n  uint public PID;\n\n  constructor(\n    string memory _name,\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    address _timelock,\n    uint _pid,\n    uint _minTokensToReinvest,\n    uint _adminFeeBips,\n    uint _devFeeBips,\n    uint _reinvestRewardBips\n  ) {\n    name = _name;\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = ILydiaChef(_stakingContract);\n    router = IRouter(_router);\n    PID = _pid;\n    devAddr = msg.sender;\n\n    setAllowances();\n    updateMinTokensToReinvest(_minTokensToReinvest);\n    updateAdminFee(_adminFeeBips);\n    updateDevFee(_devFeeBips);\n    updateReinvestReward(_reinvestRewardBips);\n    updateDepositsEnabled(true);\n    transferOwnership(_timelock);\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public override onlyOwner {\n    depositToken.approve(address(stakingContract), MAX_UINT);\n    rewardToken.approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token0()).approve(address(router), MAX_UINT);\n    IERC20(IPair(address(depositToken)).token1()).approve(address(router), MAX_UINT);\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external override {\n    _deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(msg.sender, amount);\n  }\n\n  function depositFor(address account, uint amount) external override {\n      _deposit(account, amount);\n  }\n\n  function _deposit(address account, uint amount) internal {\n    require(DEPOSITS_ENABLED == true, \"LydiaStrategyForLP::_deposit\");\n    if (MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST > 0) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards > MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST) {\n            _reinvest(unclaimedRewards);\n        }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount));\n    _stakeDepositTokens(amount);\n    _mint(account, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(account, amount);\n  }\n\n  function withdraw(uint amount) external override {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"LydiaStrategyForLP::withdraw\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  function _withdrawDepositTokens(uint amount) private {\n    require(amount > 0, \"LydiaStrategyForLP::_withdrawDepositTokens\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  function reinvest() external override onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"LydiaStrategyForLP::reinvest\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n    * @notice Reinvest rewards from staking contract to deposit tokens\n    * @dev Reverts if the expected amount of tokens are not returned from `stakingContract`\n    * @param amount deposit tokens to reinvest\n    */\n  function _reinvest(uint amount) private {\n    stakingContract.deposit(PID, 0);\n\n    uint devFee = amount.mul(DEV_FEE_BIPS).div(BIPS_DIVISOR);\n    if (devFee > 0) {\n      require(rewardToken.transfer(devAddr, devFee), \"LydiaStrategyForLP::_reinvest, dev\");\n    }\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"LydiaStrategyForLP::_reinvest, admin\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"LydiaStrategyForLP::_reinvest, reward\");\n    }\n\n    uint depositTokenAmount = _convertRewardTokensToDepositTokens(\n      amount.sub(devFee).sub(adminFee).sub(reinvestFee)\n    );\n\n    _stakeDepositTokens(depositTokenAmount);\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n    \n  function _stakeDepositTokens(uint amount) private {\n    require(amount > 0, \"LydiaStrategyForLP::_stakeDepositTokens\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  function checkReward() public override view returns (uint) {\n    uint pendingReward = stakingContract.pendingLyd(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n    * @notice Converts reward tokens to deposit tokens\n    * @dev Always converts through router; there are no price checks enabled\n    * @return deposit tokens received\n    */\n  function _convertRewardTokensToDepositTokens(uint amount) private returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"LydiaStrategyForLP::_convertRewardTokensToDepositTokens\");\n\n    // swap to token0\n    uint path0Length = 2;\n    address[] memory path0 = new address[](path0Length);\n    path0[0] = address(rewardToken);\n    path0[1] = IPair(address(depositToken)).token0();\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0Length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    uint path1Length = 2;\n    address[] memory path1 = new address[](path1Length);\n    path1[0] = path0[0];\n    path1[1] = IPair(address(depositToken)).token1();\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1Length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0Length - 1], path1[path1Length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Estimate recoverable balance\n   * @return deposit tokens\n   */\n  function estimateDeployedBalance() external override view returns (uint) {\n    (uint depositBalance, ) = stakingContract.userInfo(PID, address(this));\n    return depositBalance;\n  }\n\n  function rescueDeployedFunds(uint minReturnAmountAccepted, bool disableDeposits) external override onlyOwner {\n    uint balanceBefore = depositToken.balanceOf(address(this));\n    stakingContract.emergencyWithdraw(PID);\n    uint balanceAfter = depositToken.balanceOf(address(this));\n    require(balanceAfter.sub(balanceBefore) >= minReturnAmountAccepted, \"LydiaStrategyForLP::rescueDeployedFunds\");\n    totalDeposits = balanceAfter;\n    emit Reinvest(totalDeposits, totalSupply);\n    if (DEPOSITS_ENABLED == true && disableDeposits == true) {\n      updateDepositsEnabled(false);\n    }\n  }\n}"
    },
    "contracts/strategies/CompoundingLyd.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../YakStrategy.sol\";\nimport \"../interfaces/ILydiaChef.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\n\n/**\n * @notice Single asset strategy for LYD\n */\ncontract CompoundingLyd is YakStrategy {\n  using SafeMath for uint;\n\n  IRouter public router;\n  ILydiaChef public stakingContract;\n  IERC20 public electrum;\n\n  uint public PID;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _conversionContract,\n    address _timelock,\n    uint _pid,\n    uint _minTokensToReinvest,\n    uint _adminFeeBips,\n    uint _devFeeBips,\n    uint _reinvestRewardBips\n  ) {\n    name = _name;\n    symbol = _symbol;\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = ILydiaChef(_stakingContract);\n    electrum = IERC20(stakingContract.electrum());\n    PID = _pid;\n\n    setAllowances();\n    updateMinTokensToReinvest(_minTokensToReinvest);\n    updateAdminFee(_adminFeeBips);\n    updateDevFee(_devFeeBips);\n    updateReinvestReward(_reinvestRewardBips);\n    updateDepositsEnabled(true);\n    transferOwnership(_timelock);\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public override onlyOwner {\n    depositToken.approve(address(stakingContract), MAX_UINT);\n    electrum.approve(address(stakingContract), MAX_UINT);\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external override {\n    _deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(msg.sender, amount);\n  }\n\n  function depositFor(address account, uint amount) external override {\n      _deposit(account, amount);\n  }\n\n  /**\n   * @notice Deposit Lyd\n   * @param account address\n   * @param amount deposit token amount\n   */\n  function _deposit(address account, uint amount) internal {\n    require(DEPOSITS_ENABLED == true, \"CompoundingBamboo::_deposit\");\n    if (MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST > 0) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards > MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST) {\n            _reinvest(unclaimedRewards);\n        }\n    }\n\n    require(depositToken.transferFrom(msg.sender, address(this), amount));\n    _stakeDepositTokens(amount);\n\n    _mint(account, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(account, amount);\n  }\n\n  function withdraw(uint amount) external override {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"CompoundingBamboo::withdraw\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Withdraw Bamboo\n   * @param amount deposit tokens\n   */\n  function _withdrawDepositTokens(uint amount) private {\n    require(amount > 0, \"CompoundingBamboo::_withdrawDepositTokens\");\n    uint sBambooAmount = _getSBambooForBamboo(amount);\n    stakingContract.withdraw(PID, sBambooAmount);\n    // conversionContract.leave(sBambooAmount);\n  }\n\n  function reinvest() external override onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"CompoundingBamboo::reinvest\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n    * @notice Reinvest rewards from staking contract to deposit tokens\n    * @dev Reverts if the expected amount of tokens are not returned from `stakingContract`\n    * @param amount deposit tokens to reinvest\n    */\n  function _reinvest(uint amount) private {\n    stakingContract.deposit(PID, 0);\n\n    uint devFee = amount.mul(DEV_FEE_BIPS).div(BIPS_DIVISOR);\n    if (devFee > 0) {\n      require(rewardToken.transfer(devAddr, devFee), \"CompoundingBamboo::_reinvest, dev\");\n    }\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"CompoundingBamboo::_reinvest, admin\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"CompoundingBamboo::_reinvest, reward\");\n    }\n\n    uint depositTokenAmount = amount.sub(devFee).sub(adminFee).sub(reinvestFee);\n    _stakeDepositTokens(depositTokenAmount);\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n  \n  /**\n   * @notice Convert and stake Bamboo\n   * @param amount deposit tokens\n   */\n  function _stakeDepositTokens(uint amount) private {\n    uint sBambooAmount = _getSBambooForBamboo(amount);\n    _convertBambooToSBamboo(amount);\n    _stakeSBamboo(sBambooAmount);\n  }\n\n  /**\n   * @notice Convert bamboo to sBamboo\n   * @param amount deposit token\n   */\n  function _convertBambooToSBamboo(uint amount) private {\n    require(amount > 0, \"CompoundingBamboo::_convertBambooToSBamboo\");\n    // conversionContract.enter(amount);\n  }\n\n  /**\n   * @notice Stake sBamboo\n   * @param amount sBamboo\n   */\n  function _stakeSBamboo(uint amount) private {\n    require(amount > 0, \"CompoundingBamboo::_stakeSBamboo\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  function checkReward() public override view returns (uint) {\n    uint pendingReward = stakingContract.pendingLyd(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate recoverable balance\n   * @return deposit tokens\n   */\n  function estimateDeployedBalance() external override view returns (uint) {\n    (uint depositBalance, ) = stakingContract.userInfo(PID, address(this));\n    return _getBambooForSBamboo(depositBalance);\n  }\n\n  /**\n   * @notice Conversion rate for Bamboo to sBamboo\n   * @param amount Bamboo tokens\n   * @return sBamboo shares\n   */\n  function _getSBambooForBamboo(uint amount) private view returns (uint) {\n    uint bambooBalance = depositToken.balanceOf(address(stakingContract));\n    uint sBambooShares = electrum.totalSupply();\n    if (bambooBalance.mul(sBambooShares) == 0) {\n      return amount;\n    }\n    return amount.mul(sBambooShares).div(bambooBalance);\n  }\n\n  /**\n   * @notice Conversion rate for sBamboo to Bamboo\n   * @param amount sBamboo shares\n   * @return Bamboo tokens\n   */\n  function _getBambooForSBamboo(uint amount) private view returns (uint) {\n    uint bambooBalance = depositToken.balanceOf(address(stakingContract));\n    uint sBambooShares = electrum.totalSupply();\n    if (bambooBalance.mul(sBambooShares) == 0) {\n      return amount;\n    }\n    return amount.mul(bambooBalance).div(sBambooShares);\n  }\n\n  function rescueDeployedFunds(uint minReturnAmountAccepted, bool disableDeposits) external override onlyOwner {\n    uint balanceBefore = depositToken.balanceOf(address(this));\n    stakingContract.emergencyWithdraw(PID);\n    // conversionContract.leave(sBamboo.balanceOf(address(this)));\n    uint balanceAfter = depositToken.balanceOf(address(this));\n    require(balanceAfter.sub(balanceBefore) >= minReturnAmountAccepted, \"CompoundingBamboo::rescueDeployedFunds\");\n    totalDeposits = balanceAfter;\n    emit Reinvest(totalDeposits, totalSupply);\n    if (DEPOSITS_ENABLED == true && disableDeposits == true) {\n      updateDepositsEnabled(false);\n    }\n  }\n}"
    },
    "contracts/strategies/DexStrategyV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../YakStrategy.sol\";\nimport \"../interfaces/IStakingRewards.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\n\n/**\n * @notice Pool2 strategy for StakingRewards\n */\ncontract DexStrategyV4 is YakStrategy {\n    using SafeMath for uint;\n\n    IStakingRewards public stakingContract;\n    IRouter public router;\n\n    constructor (\n        string memory _name,\n        address _depositToken,\n        address _rewardToken,\n        address _stakingContract,\n        address _router,\n        address _timelock,\n        uint _minTokensToReinvest,\n        uint _adminFeeBips,\n        uint _devFeeBips,\n        uint _reinvestRewardBips\n    ) {\n        name = _name;\n        depositToken = IERC20(_depositToken);\n        rewardToken = IERC20(_rewardToken);\n        stakingContract = IStakingRewards(_stakingContract);\n        router = IRouter(_router);\n        devAddr = msg.sender;\n\n        setAllowances();\n        updateMinTokensToReinvest(_minTokensToReinvest);\n        updateAdminFee(_adminFeeBips);\n        updateDevFee(_devFeeBips);\n        updateReinvestReward(_reinvestRewardBips);\n        updateDepositsEnabled(true);\n        transferOwnership(_timelock);\n\n        emit Reinvest(0, 0);\n    }\n\n    function setAllowances() public override onlyOwner {\n        depositToken.approve(address(stakingContract), MAX_UINT);\n        rewardToken.approve(address(router), MAX_UINT);\n        IERC20(IPair(address(depositToken)).token0()).approve(address(router), MAX_UINT);\n        IERC20(IPair(address(depositToken)).token1()).approve(address(router), MAX_UINT);\n    }\n\n    function deposit(uint amount) external override {\n        _deposit(msg.sender, amount);\n    }\n\n    function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n        depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n        _deposit(msg.sender, amount);\n    }\n\n    function depositFor(address account, uint amount) external override {\n        _deposit(account, amount);\n    }\n\n    function _deposit(address account, uint amount) private onlyAllowedDeposits {\n        require(DEPOSITS_ENABLED == true, \"DexStrategyV4::_deposit\");\n        if (MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST > 0) {\n            uint unclaimedRewards = checkReward();\n            if (unclaimedRewards > MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST) {\n                _reinvest(unclaimedRewards);\n            }\n        }\n        require(depositToken.transferFrom(msg.sender, address(this), amount));\n        _stakeDepositTokens(amount);\n        _mint(account, getSharesForDepositTokens(amount));\n        totalDeposits = totalDeposits.add(amount);\n        emit Deposit(account, amount);\n    }\n\n    function withdraw(uint amount) external override {\n        uint depositTokenAmount = getDepositTokensForShares(amount);\n        if (depositTokenAmount > 0) {\n            _withdrawDepositTokens(depositTokenAmount);\n            require(depositToken.transfer(msg.sender, depositTokenAmount), \"DexStrategyV4::withdraw\");\n            _burn(msg.sender, amount);\n            totalDeposits = totalDeposits.sub(depositTokenAmount);\n            emit Withdraw(msg.sender, depositTokenAmount);\n        }\n    }\n\n    function _withdrawDepositTokens(uint amount) private {\n        require(amount > 0, \"DexStrategyV4::_withdrawDepositTokens\");\n        stakingContract.withdraw(amount);\n    }\n\n    function reinvest() external override onlyEOA {\n        uint unclaimedRewards = checkReward();\n        require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"DexStrategyV4::reinvest\");\n        _reinvest(unclaimedRewards);\n    }\n\n    /**\n     * @notice Reinvest rewards from staking contract to deposit tokens\n     * @dev Reverts if the expected amount of tokens are not returned from `stakingContract`\n     * @param amount deposit tokens to reinvest\n     */\n    function _reinvest(uint amount) private {\n        stakingContract.getReward();\n\n        uint devFee = amount.mul(DEV_FEE_BIPS).div(BIPS_DIVISOR);\n        if (devFee > 0) {\n            require(rewardToken.transfer(devAddr, devFee), \"DexStrategyV4::_reinvest, dev\");\n        }\n\n        uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n        if (adminFee > 0) {\n            require(rewardToken.transfer(owner(), adminFee), \"DexStrategyV4::_reinvest, admin\");\n        }\n\n        uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n        if (reinvestFee > 0) {\n            require(rewardToken.transfer(msg.sender, reinvestFee), \"DexStrategyV4::_reinvest, reward\");\n        }\n\n        uint depositTokenAmount = _convertRewardTokensToDepositTokens(\n            amount.sub(devFee).sub(adminFee).sub(reinvestFee)\n        );\n\n        _stakeDepositTokens(depositTokenAmount);\n        totalDeposits = totalDeposits.add(depositTokenAmount);\n\n        emit Reinvest(totalDeposits, totalSupply);\n    }\n    \n    function _stakeDepositTokens(uint amount) private {\n        require(amount > 0, \"DexStrategyV4::_stakeDepositTokens\");\n        stakingContract.stake(amount);\n    }\n\n    /**\n     * @notice Converts reward tokens to deposit tokens\n     * @dev Always converts through router; there are no price checks enabled\n     * @return deposit tokens received\n     */\n    function _convertRewardTokensToDepositTokens(uint amount) private returns (uint) {\n        uint amountIn = amount.div(2);\n        require(amountIn > 0, \"DexStrategyV4::_convertRewardTokensToDepositTokens\");\n\n        // swap to token0\n        uint path0Length = 2;\n        address[] memory path0 = new address[](path0Length);\n        path0[0] = address(rewardToken);\n        path0[1] = IPair(address(depositToken)).token0();\n\n        uint amountOutToken0 = amountIn;\n        if (path0[0] != path0[path0Length - 1]) {\n            uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n            amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n            router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n        }\n\n        // swap to token1\n        uint path1Length = 2;\n        address[] memory path1 = new address[](path1Length);\n        path1[0] = path0[0];\n        path1[1] = IPair(address(depositToken)).token1();\n\n        uint amountOutToken1 = amountIn;\n        if (path1[0] != path1[path1Length - 1]) {\n            uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n            amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n            router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n        }\n\n        (,,uint liquidity) = router.addLiquidity(\n            path0[path0Length - 1], path1[path1Length - 1],\n            amountOutToken0, amountOutToken1,\n            0, 0,\n            address(this),\n            block.timestamp\n        );\n\n        return liquidity;\n    }\n\n    \n    function checkReward() public override view returns (uint) {\n        return stakingContract.earned(address(this));\n    }\n\n    function estimateDeployedBalance() external override view returns (uint) {\n        return stakingContract.balanceOf(address(this));\n    }\n\n    function rescueDeployedFunds(uint minReturnAmountAccepted, bool disableDeposits) external override onlyOwner {\n        uint balanceBefore = depositToken.balanceOf(address(this));\n        stakingContract.exit();\n        uint balanceAfter = depositToken.balanceOf(address(this));\n        require(balanceAfter.sub(balanceBefore) >= minReturnAmountAccepted, \"DexStrategyV4::rescueDeployedFunds\");\n        totalDeposits = balanceAfter;\n        emit Reinvest(totalDeposits, totalSupply);\n        if (DEPOSITS_ENABLED == true && disableDeposits == true) {\n            updateDepositsEnabled(false);\n        }\n    }\n}"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IStakingRewards {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function lastTimeRewardApplicable() external view returns (uint256);\n    function rewardPerToken() external view returns (uint256);\n    function earned(address account) external view returns (uint256);\n    function getRewardForDuration() external view returns (uint256);\n    function stake(uint256 amount) external;\n    function stakeWithPermit(uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function withdraw(uint256 amount) external;\n    function getReward() external;\n    function exit() external;\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n}"
    },
    "contracts/DexStrategyV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract DexStrategyV3 is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IStakingRewards public stakingContract;\n\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  uint constant internal UINT_MAX = uint256(-1);\n\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken,\n    address _rewardToken, \n    address _stakingContract, \n    address _router\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IStakingRewards(_stakingContract);\n    router = IRouter(_router);\n\n    address _token0 = IPair(depositToken).token0();\n    address _token1 = IPair(depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    setAllowances();\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public onlyOwner {\n    depositToken.approve(address(stakingContract), UINT_MAX);\n    rewardToken.approve(address(router), UINT_MAX);\n    token0.approve(address(router), UINT_MAX);\n    token1.approve(address(router), UINT_MAX);\n  }\n\n  /**\n    * @notice Revoke token allowance\n    * @dev Restricted to avoid griefing attacks\n    * @param token address\n    * @param spender address\n    */\n  function revokeAllowance(address token, address spender) external onlyOwner {\n    require(IERC20(token).approve(spender, 0));\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Unclaimed rewards from staking contract\n   * @return Unclaimed rewards from staking contract\n   */\n  function checkReward() public view returns (uint) {\n    return stakingContract.earned(address(this));\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.getReward();\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[1], path1[1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.stake(amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.exit();\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    require(tokenAddress != address(depositToken), \"cannot recover deposit token\");\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/OliveStrategyForSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IOliveChef.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract OliveStrategyForSA is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IERC20 public depositToken;\n  IERC20 public rewardToken;\n  IOliveChef public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  uint constant private UINT_MAX = uint256(-1);\n\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    uint _pid\n  ) {\n    depositToken = IERC20(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IOliveChef(_stakingContract);\n\n    PID = _pid;\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol()\n      )\n    );\n\n    setAllowances();\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public onlyOwner {\n    depositToken.approve(address(stakingContract), UINT_MAX);\n  }\n\n  /**\n    * @notice Revoke token allowance\n    * @dev Restricted to avoid griefing attacks\n    * @param token address\n    * @param spender address\n    */\n  function revokeAllowance(address token, address spender) external onlyOwner {\n    require(IERC20(token).approve(spender, 0));\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingOlive(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint depositTokensToAdd = amount.sub(adminFee).sub(reinvestFee);\n    _stakeDepositTokens(depositTokensToAdd);\n    totalDeposits = totalDeposits.add(depositTokensToAdd);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/interfaces/IOliveChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IOliveChef {\n    function olive() external view returns (address);\n    function olivePerBlock() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function add(uint256 _allocPoint, address _lpToken, bool _withUpdate) external;\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n    function pendingOlive(uint256 _pid, address _user) external view returns (uint256);\n    function massUpdatePools() external;\n    function updatePool(uint256 _pid) external;\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function dev(address _devaddr) external;\n    function poolInfo(uint pid) external view returns (\n        address lpToken,\n        uint allocPoint,\n        uint lastRewardBlock,\n        uint accOlivePerShare\n    );\n    function userInfo(uint pid, address user) external view returns (\n        uint256 amount,\n        uint256 rewardDebt\n    );\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n}"
    },
    "contracts/OliveStrategyForLPc.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IOliveChef.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract OliveStrategyForLPc is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IOliveChef public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  uint constant private UINT_MAX = uint256(-1);\n  address constant private WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IOliveChef(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_depositToken).token0();\n    address _token1 = IPair(_depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    setAllowances();\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public onlyOwner {\n    depositToken.approve(address(stakingContract), UINT_MAX);\n    rewardToken.approve(address(router), UINT_MAX);\n    token0.approve(address(router), UINT_MAX);\n    token1.approve(address(router), UINT_MAX);\n  }\n\n  /**\n    * @notice Revoke token allowance\n    * @dev Restricted to avoid griefing attacks\n    * @param token address\n    * @param spender address\n    */\n  function revokeAllowance(address token, address spender) external onlyOwner {\n    require(IERC20(token).approve(spender, 0));\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingOlive(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](3);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token1);\n    path0[2] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0.length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1.length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0.length - 1], path1[path1.length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    require(tokenAddress != address(depositToken), \"cannot recover deposit token\");\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/OliveStrategyForLPb.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IOliveChef.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract OliveStrategyForLPb is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IOliveChef public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  uint constant private UINT_MAX = uint256(-1);\n  address constant private WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IOliveChef(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_depositToken).token0();\n    address _token1 = IPair(_depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    setAllowances();\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public onlyOwner {\n    depositToken.approve(address(stakingContract), UINT_MAX);\n    rewardToken.approve(address(router), UINT_MAX);\n    token0.approve(address(router), UINT_MAX);\n    token1.approve(address(router), UINT_MAX);\n  }\n\n  /**\n    * @notice Revoke token allowance\n    * @dev Restricted to avoid griefing attacks\n    * @param token address\n    * @param spender address\n    */\n  function revokeAllowance(address token, address spender) external onlyOwner {\n    require(IERC20(token).approve(spender, 0));\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingOlive(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0.length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](3);\n    path1[0] = path0[0];\n    path1[1] = WAVAX;\n    path1[2] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1.length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0.length - 1], path1[path1.length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    require(tokenAddress != address(depositToken), \"cannot recover deposit token\");\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/OliveStrategyForLPa.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IOliveChef.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract OliveStrategyForLPa is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IOliveChef public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  uint constant private UINT_MAX = uint256(-1);\n  address constant private WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IOliveChef(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_depositToken).token0();\n    address _token1 = IPair(_depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    setAllowances();\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public onlyOwner {\n    depositToken.approve(address(stakingContract), UINT_MAX);\n    rewardToken.approve(address(router), UINT_MAX);\n    token0.approve(address(router), UINT_MAX);\n    token1.approve(address(router), UINT_MAX);\n  }\n\n  /**\n    * @notice Revoke token allowance\n    * @dev Restricted to avoid griefing attacks\n    * @param token address\n    * @param spender address\n    */\n  function revokeAllowance(address token, address spender) external onlyOwner {\n    require(IERC20(token).approve(spender, 0));\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingOlive(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](3);\n    path0[0] = address(rewardToken);\n    path0[1] = WAVAX;\n    path0[2] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0.length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1.length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0.length - 1], path1[path1.length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    require(tokenAddress != address(depositToken), \"cannot recover deposit token\");\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/OliveStrategyForLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IOliveChef.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract OliveStrategyForLP is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IOliveChef public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  uint constant internal UINT_MAX = uint256(-1);\n\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IOliveChef(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_depositToken).token0();\n    address _token1 = IPair(_depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    setAllowances();\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public onlyOwner {\n    depositToken.approve(address(stakingContract), UINT_MAX);\n    rewardToken.approve(address(router), UINT_MAX);\n    token0.approve(address(router), UINT_MAX);\n    token1.approve(address(router), UINT_MAX);\n  }\n\n  /**\n    * @notice Revoke token allowance\n    * @dev Restricted to avoid griefing attacks\n    * @param token address\n    * @param spender address\n    */\n  function revokeAllowance(address token, address spender) external onlyOwner {\n    require(IERC20(token).approve(spender, 0));\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingOlive(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[1], path1[1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    require(tokenAddress != address(depositToken), \"cannot recover deposit token\");\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/IceQueenStrategyV2b.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SnowballERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IIceQueen.sol\";\nimport \"./interfaces/ISnowGlobe.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract IceQueenStrategyV2b is SnowballERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  ISnowGlobe public depositToken;\n  IPair public lpToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IIceQueen public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address account, uint amount);\n  event Withdraw(address account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken,\n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = ISnowGlobe(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IIceQueen(_stakingContract);\n    router = IRouter(_router);\n\n    address _lpToken = ISnowGlobe(_depositToken).token();\n    lpToken = IPair(_lpToken);\n\n    PID = _pid;\n\n    address _token0 = IPair(_lpToken).token0();\n    address _token1 = IPair(_lpToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Snowball: \",\n        ISnowGlobe(_depositToken).symbol(), \" (\",\n        lpToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol(), \")\"\n      )\n    );\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Set approvals for tokens\n   * @param tokensToApprove tokens to approve\n   * @param approvalAmounts approval amounts\n   * @param spenders address allowed to spend tokens\n   */\n  function tokenAllow(\n      address[] memory tokensToApprove, \n      uint256[] memory approvalAmounts, \n      address[] memory spenders\n  ) external onlyOwner {\n    require(\n      tokensToApprove.length == approvalAmounts.length\n      && tokensToApprove.length == spenders.length\n    , \"not same length\");\n    for(uint i = 0; i < tokensToApprove.length; i++) {\n      IERC20 token = IERC20(tokensToApprove[i]);\n      uint allowance = token.allowance(address(this), spenders[i]);\n      if (\n        allowance != approvalAmounts[i] &&\n        (allowance != uint256(-1) || approvalAmounts[i] == 0)\n      ) {\n        require(token.approve(spenders[i], approvalAmounts[i]), \"approve failed\");\n      }\n    }\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   */\n  function deposit(uint amount) external {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForLPTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw deposit tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getLPTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @dev Note: misleading name (consider rename to \"getReceiptTokensForDepositTokens\")\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForLPTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @dev Note: misleading name (consider rename to \"getDepositTokensForReceiptTokens\")\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getLPTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingSnowball(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward\n   * @return Estimated reward tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to LP tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToLpTokens(amount.sub(adminFee).sub(reinvestFee));\n    uint depositTokenAmount = _convertLpTokensToDepositTokens(lpTokenAmount);\n    _stakeDepositTokens(depositTokenAmount);\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts intermediary LP tokens to deposit tokens\n   * @dev Function `deposit(uint)` does not return an amount and is calculated\n   * @dev Do NOT rely on output amount for non-standard token supply mechanisms (e.g. fee on transfer)\n   * @return deposit tokens received\n   */\n  function _convertLpTokensToDepositTokens(uint amount) internal returns (uint) {\n    require(amount > 0, \"amount too low\");\n    uint256 _pool = depositToken.balance();\n    uint256 _totalSupply = depositToken.totalSupply();\n    uint256 shares = 0;\n    if (_totalSupply == 0) {\n        shares = amount;\n    } else {\n        shares = (amount.mul(_totalSupply)).div(_pool);\n    }\n    depositToken.deposit(amount);\n    return shares;\n  }\n\n  /**\n   * @notice Converts entire reward token balance to intermediary LP tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return LP tokens received\n   */\n  function _convertRewardTokensToLpTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0.length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](3);\n    path1[0] = path0[0];\n    path1[1] = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    path1[2] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1.length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0.length - 1], path1[path1.length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/interfaces/IIceQueen.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IIceQueen {\n    function poolLength() external view returns (uint256);\n    function setComPerBlock(uint256 _newPerBlock) external;\n    function add(uint256 _allocPoint, address _lpToken, bool _withUpdate) external;\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n    function setMigrator(address _migrator) external;\n    function migrate(uint256 _pid) external;\n    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n    function pendingSnowball(uint256 _pid, address _user) external view returns (uint256);\n    function massUpdatePools() external;\n    function updatePool(uint256 _pid) external;\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function dev(address _devaddr) external;\n    event Recovered(address token, uint256 amount);\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n}\n"
    },
    "contracts/interfaces/ISnowGlobe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface ISnowGlobe {\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n\n    function token() external view returns (address);\n    function min() external view returns (uint256);\n    function max() external view returns (uint256);\n\n    function governance() external view returns (address);\n    function timelock() external view returns (address);\n    function controller() external view returns (address);\n\n    function depositAll() external;\n    function earn() external;\n    function available() external view returns (uint256);\n    function setController(address _controller) external;\n    function getRatio() external view returns (uint256);\n    function balance() external view returns (uint256);\n    function deposit(uint256 _amount) external;\n    function withdraw(uint256 _shares) external;\n    function withdrawAll() external;\n    function harvest(address reserve, uint256 amount) external;\n}"
    },
    "contracts/IceQueenStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SnowballERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IIceQueen.sol\";\nimport \"./interfaces/ISnowGlobe.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract IceQueenStrategyV2 is SnowballERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  ISnowGlobe public depositToken;\n  IPair public lpToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IIceQueen public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address account, uint amount);\n  event Withdraw(address account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken,\n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = ISnowGlobe(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IIceQueen(_stakingContract);\n    router = IRouter(_router);\n\n    address _lpToken = ISnowGlobe(_depositToken).token();\n    lpToken = IPair(_lpToken);\n\n    PID = _pid;\n\n    address _token0 = IPair(_lpToken).token0();\n    address _token1 = IPair(_lpToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Snowball: \",\n        ISnowGlobe(_depositToken).symbol(), \" (\",\n        lpToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol(), \")\"\n      )\n    );\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Set approvals for tokens\n   * @param tokensToApprove tokens to approve\n   * @param approvalAmounts approval amounts\n   * @param spenders address allowed to spend tokens\n   */\n  function tokenAllow(\n      address[] memory tokensToApprove, \n      uint256[] memory approvalAmounts, \n      address[] memory spenders\n  ) external onlyOwner {\n    require(\n      tokensToApprove.length == approvalAmounts.length\n      && tokensToApprove.length == spenders.length\n    , \"not same length\");\n    for(uint i = 0; i < tokensToApprove.length; i++) {\n      IERC20 token = IERC20(tokensToApprove[i]);\n      uint allowance = token.allowance(address(this), spenders[i]);\n      if (\n        allowance != approvalAmounts[i] &&\n        (allowance != uint256(-1) || approvalAmounts[i] == 0)\n      ) {\n        require(token.approve(spenders[i], approvalAmounts[i]), \"approve failed\");\n      }\n    }\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   */\n  function deposit(uint amount) external {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForLPTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw deposit tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getLPTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @dev Note: misleading name (consider rename to \"getReceiptTokensForDepositTokens\")\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForLPTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @dev Note: misleading name (consider rename to \"getDepositTokensForReceiptTokens\")\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getLPTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingSnowball(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward\n   * @return Estimated reward tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to LP tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToLpTokens(amount.sub(adminFee).sub(reinvestFee));\n    uint depositTokenAmount = _convertLpTokensToDepositTokens(lpTokenAmount);\n    _stakeDepositTokens(depositTokenAmount);\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts intermediary LP tokens to deposit tokens\n   * @dev Function `deposit(uint)` does not return an amount and is calculated\n   * @dev Do NOT rely on output amount for non-standard token supply mechanisms (e.g. fee on transfer)\n   * @return deposit tokens received\n   */\n  function _convertLpTokensToDepositTokens(uint amount) internal returns (uint) {\n    require(amount > 0, \"amount too low\");\n    uint256 _pool = depositToken.balance();\n    uint256 _totalSupply = depositToken.totalSupply();\n    uint256 shares = 0;\n    if (_totalSupply == 0) {\n        shares = amount;\n    } else {\n        shares = (amount.mul(_totalSupply)).div(_pool);\n    }\n    depositToken.deposit(amount);\n    return shares;\n  }\n\n  /**\n   * @notice Converts entire reward token balance to intermediary LP tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return LP tokens received\n   */\n  function _convertRewardTokensToLpTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](3);\n    path0[0] = address(rewardToken);\n    path0[1] = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    path0[2] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0.length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1.length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0.length - 1], path1[path1.length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/IceQueenStrategy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SnowballERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IIceQueen.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract IceQueenStrategy is SnowballERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public lpToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IIceQueen public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n\n  event Deposit(address account, uint amount);\n  event Withdraw(address account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n\n  constructor(\n    address _lpToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    lpToken = IPair(_lpToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IIceQueen(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_lpToken).token0();\n    address _token1 = IPair(_lpToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    IERC20(_rewardToken).approve(_router, uint(-1));\n    IERC20(_token0).approve(_router, uint(-1));\n    IERC20(_token1).approve(_router, uint(-1));\n    IPair(_lpToken).approve(_stakingContract, uint(-1));\n\n    name = string(\n      abi.encodePacked(\n        \"Snowball: \",\n        lpToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    lpToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    require(lpToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeLpTokens(amount);\n    _mint(msg.sender, getSharesForLPTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming Snowball tokens\n   * @param amount Amount of Snowball tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint lpTokenAmount = getLPTokensForShares(amount);\n    if (lpTokenAmount > 0) {\n      _withdrawLpTokens(lpTokenAmount);\n      require(lpToken.transfer(msg.sender, lpTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(lpTokenAmount);\n      emit Withdraw(msg.sender, lpTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate Snowball tokens for a given amount of LP tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of LP tokens\n   * @param amount LP tokens\n   * @return Snowball tokens\n   */\n  function getSharesForLPTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate LP tokens for a given amount of Snowball tokens\n   * @param amount Snowball tokens\n   * @return LP tokens\n   */\n  function getLPTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingSnowball(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to LP tokens\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = unclaimedRewards.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToLpTokens(unclaimedRewards.sub(adminFee).sub(reinvestFee));\n    _stakeLpTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to LP tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return LP tokens received\n   */\n  function _convertRewardTokensToLpTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[1], path1[1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes LP tokens in Staking Contract\n   * @param amount LP tokens to stake\n   */\n  function _stakeLpTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws LP tokens from Staking Contract\n   * @dev Rewards are not automatically collected from the Staking Contract\n   * @param amount LP tokens to remove;\n   */\n  function _withdrawLpTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/DexStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SnowballERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract DexStrategyV2 is SnowballERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IStakingRewards public stakingContract;\n\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken,\n    address _rewardToken, \n    address _stakingContract, \n    address _router\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IStakingRewards(_stakingContract);\n    router = IRouter(_router);\n\n    address _token0 = IPair(depositToken).token0();\n    address _token1 = IPair(depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Snowball: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Set approvals for tokens\n   * @param tokensToApprove tokens to approve\n   * @param approvalAmounts approval amounts\n   * @param spenders address allowed to spend tokens\n   */\n  function tokenAllow(\n      address[] memory tokensToApprove, \n      uint256[] memory approvalAmounts, \n      address[] memory spenders\n  ) external onlyOwner {\n    require(\n      tokensToApprove.length == approvalAmounts.length\n      && tokensToApprove.length == spenders.length\n    , \"not same length\");\n    for(uint i = 0; i < tokensToApprove.length; i++) {\n      IERC20 token = IERC20(tokensToApprove[i]);\n      uint allowance = token.allowance(address(this), spenders[i]);\n      if (\n        allowance != approvalAmounts[i] &&\n        (allowance != uint256(-1) || approvalAmounts[i] == 0)\n      ) {\n        require(token.approve(spenders[i], approvalAmounts[i]), \"approve failed\");\n      }\n    }\n  }\n\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Unclaimed rewards from staking contract\n   * @return Unclaimed rewards from staking contract\n   */\n  function checkReward() public view returns (uint) {\n    return stakingContract.earned(address(this));\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.getReward();\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[1], path1[1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.stake(amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.exit();\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/DexStrategy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SnowballERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract DexStrategy is SnowballERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public lpToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IStakingRewards public stakingContract;\n\n  uint public MIN_TOKENS_TO_REINVEST = 20;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n\n  event Deposit(address account, uint amount);\n  event Withdraw(address account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n\n  constructor(address _lpToken, address _rewardToken, address _stakingContract, address _router) {\n    lpToken = IPair(_lpToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IStakingRewards(_stakingContract);\n    router = IRouter(_router);\n\n    address _token0 = IPair(_lpToken).token0();\n    address _token1 = IPair(_lpToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    IERC20(_rewardToken).approve(_router, uint(-1));\n    IERC20(_token0).approve(_router, uint(-1));\n    IERC20(_token1).approve(_router, uint(-1));\n    IPair(_lpToken).approve(_stakingContract, uint(-1));\n\n    name = string(\n      abi.encodePacked(\n        \"Snowball: \",\n        lpToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    lpToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    require(lpToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeLpTokens(amount);\n    _mint(msg.sender, getSharesForLPTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming Snowball tokens\n   * @param amount Amount of Snowball tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint lpTokenAmount = getLPTokensForShares(amount);\n    if (lpTokenAmount > 0) {\n      _withdrawLpTokens(lpTokenAmount);\n      require(lpToken.transfer(msg.sender, lpTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(lpTokenAmount);\n      emit Withdraw(msg.sender, lpTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate Snowball tokens for a given amount of LP tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of LP tokens\n   * @param amount LP tokens\n   * @return Snowball tokens\n   */\n  function getSharesForLPTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate LP tokens for a given amount of Snowball tokens\n   * @param amount Snowball tokens\n   * @return LP tokens\n   */\n  function getLPTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Unclaimed rewards from staking contract\n   * @return Unclaimed rewards from staking contract\n   */\n  function checkReward() public view returns (uint) {\n    return stakingContract.earned(address(this));\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to LP tokens\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    stakingContract.getReward();\n\n    uint adminFee = unclaimedRewards.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToLpTokens(unclaimedRewards.sub(adminFee).sub(reinvestFee));\n    _stakeLpTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to LP tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return LP tokens received\n   */\n  function _convertRewardTokensToLpTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[1], path1[1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes LP tokens in Staking Contract\n   * @param amount LP tokens to stake\n   */\n  function _stakeLpTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.stake(amount);\n  }\n\n  /**\n   * @notice Withdraws LP tokens from Staking Contract\n   * @dev Rewards are not automatically collected from the Staking Contract\n   * @param amount LP tokens to remove;\n   */\n  function _withdrawLpTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.exit();\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/strategies/CompoundingBamboo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../YakStrategy.sol\";\nimport \"../interfaces/IBambooChef.sol\";\nimport \"../interfaces/IBambooBar.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\n\n/**\n * @notice Single asset strategy for BAMBOO\n */\ncontract CompoundingBamboo is YakStrategy {\n  using SafeMath for uint;\n\n  IRouter public router;\n  IBambooChef public stakingContract;\n  IBambooBar public conversionContract;\n  IERC20 public sBamboo;\n\n  uint public PID;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _conversionContract,\n    address _timelock,\n    uint _pid,\n    uint _minTokensToReinvest,\n    uint _adminFeeBips,\n    uint _devFeeBips,\n    uint _reinvestRewardBips\n  ) {\n    name = _name;\n    symbol = _symbol;\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IBambooChef(_stakingContract);\n    conversionContract = IBambooBar(_conversionContract);\n    sBamboo = IERC20(_conversionContract);\n    PID = _pid;\n    devAddr = 0xD15E8b816F040fB0d7495ebA36C16Cf0f33c049c;\n\n    setAllowances();\n    updateMinTokensToReinvest(_minTokensToReinvest);\n    updateAdminFee(_adminFeeBips);\n    updateDevFee(_devFeeBips);\n    updateReinvestReward(_reinvestRewardBips);\n    updateDepositsEnabled(true);\n    transferOwnership(_timelock);\n\n    emit Reinvest(0, 0);\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public override onlyOwner {\n    depositToken.approve(address(conversionContract), MAX_UINT);\n    sBamboo.approve(address(stakingContract), MAX_UINT);\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external override {\n    _deposit(address(depositToken), msg.sender, amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(address(depositToken), msg.sender, amount);\n  }\n\n  function depositFor(address account, uint amount) external override {\n      _deposit(address(depositToken), account, amount);\n  }\n\n  function depositSBamboo(uint amount) external {\n    _deposit(address(sBamboo), msg.sender, amount);\n  }\n\n  function depositSBambooWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    sBamboo.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(address(sBamboo), msg.sender, amount);\n  }\n\n  function depositSBambooFor(address account, uint amount) external {\n      _deposit(address(sBamboo), account, amount);\n  }\n\n  /**\n   * @notice Deposit Bamboo or sBamboo\n   * @param token address\n   * @param account address\n   * @param amount token amount\n   */\n  function _deposit(address token, address account, uint amount) internal {\n    require(DEPOSITS_ENABLED == true, \"CompoundingBamboo::_deposit\");\n    require(token == address(depositToken) || token == address(sBamboo), \"CompoundingBamboo::_deposit, token not accepted\");\n    if (MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST > 0) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards > MAX_TOKENS_TO_DEPOSIT_WITHOUT_REINVEST) {\n            _reinvest(unclaimedRewards);\n        }\n    }\n\n    uint depositTokenAmount;\n    if (token == address(depositToken)) {\n      require(depositToken.transferFrom(msg.sender, address(this), amount));\n      depositTokenAmount = amount;\n      _stakeDepositTokens(amount);\n    }\n    else if (token == address(sBamboo)) {\n      require(sBamboo.transferFrom(msg.sender, address(this), amount));\n      depositTokenAmount = _getBambooForSBamboo(amount);\n      _stakeSBamboo(amount);\n    }\n\n    _mint(account, getSharesForDepositTokens(depositTokenAmount));\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n    emit Deposit(account, depositTokenAmount);\n  }\n\n  function withdraw(uint amount) external override {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"CompoundingBamboo::withdraw\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Withdraw Bamboo\n   * @param amount deposit tokens\n   */\n  function _withdrawDepositTokens(uint amount) private {\n    require(amount > 0, \"CompoundingBamboo::_withdrawDepositTokens\");\n    uint sBambooAmount = _getSBambooForBamboo(amount);\n    stakingContract.withdraw(PID, sBambooAmount);\n    conversionContract.leave(sBambooAmount);\n  }\n\n  function reinvest() external override onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"CompoundingBamboo::reinvest\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n    * @notice Reinvest rewards from staking contract to deposit tokens\n    * @dev Reverts if the expected amount of tokens are not returned from `stakingContract`\n    * @param amount deposit tokens to reinvest\n    */\n  function _reinvest(uint amount) private {\n    stakingContract.deposit(PID, 0);\n\n    uint devFee = amount.mul(DEV_FEE_BIPS).div(BIPS_DIVISOR);\n    if (devFee > 0) {\n      require(rewardToken.transfer(devAddr, devFee), \"CompoundingBamboo::_reinvest, dev\");\n    }\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"CompoundingBamboo::_reinvest, admin\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"CompoundingBamboo::_reinvest, reward\");\n    }\n\n    uint depositTokenAmount = amount.sub(devFee).sub(adminFee).sub(reinvestFee);\n    _stakeDepositTokens(depositTokenAmount);\n    totalDeposits = totalDeposits.add(depositTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n  \n  /**\n   * @notice Convert and stake Bamboo\n   * @param amount deposit tokens\n   */\n  function _stakeDepositTokens(uint amount) private {\n    uint sBambooAmount = _getSBambooForBamboo(amount);\n    _convertBambooToSBamboo(amount);\n    _stakeSBamboo(sBambooAmount);\n  }\n\n  /**\n   * @notice Convert bamboo to sBamboo\n   * @param amount deposit token\n   */\n  function _convertBambooToSBamboo(uint amount) private {\n    require(amount > 0, \"CompoundingBamboo::_convertBambooToSBamboo\");\n    conversionContract.enter(amount);\n  }\n\n  /**\n   * @notice Stake sBamboo\n   * @param amount sBamboo\n   */\n  function _stakeSBamboo(uint amount) private {\n    require(amount > 0, \"CompoundingBamboo::_stakeSBamboo\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  function checkReward() public override view returns (uint) {\n    uint pendingReward = stakingContract.pendingBamboo(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate recoverable balance\n   * @return deposit tokens\n   */\n  function estimateDeployedBalance() external override view returns (uint) {\n    (uint depositBalance, ) = stakingContract.userInfo(PID, address(this));\n    return _getBambooForSBamboo(depositBalance);\n  }\n\n  /**\n   * @notice Conversion rate for Bamboo to sBamboo\n   * @param amount Bamboo tokens\n   * @return sBamboo shares\n   */\n  function _getSBambooForBamboo(uint amount) private view returns (uint) {\n    uint bambooBalance = depositToken.balanceOf(address(conversionContract));\n    uint sBambooShares = sBamboo.totalSupply();\n    if (bambooBalance.mul(sBambooShares) == 0) {\n      return amount;\n    }\n    return amount.mul(sBambooShares).div(bambooBalance);\n  }\n\n  /**\n   * @notice Conversion rate for sBamboo to Bamboo\n   * @param amount sBamboo shares\n   * @return Bamboo tokens\n   */\n  function _getBambooForSBamboo(uint amount) private view returns (uint) {\n    uint bambooBalance = depositToken.balanceOf(address(conversionContract));\n    uint sBambooShares = sBamboo.totalSupply();\n    if (bambooBalance.mul(sBambooShares) == 0) {\n      return amount;\n    }\n    return amount.mul(bambooBalance).div(sBambooShares);\n  }\n\n  function rescueDeployedFunds(uint minReturnAmountAccepted, bool disableDeposits) external override onlyOwner {\n    uint balanceBefore = depositToken.balanceOf(address(this));\n    stakingContract.emergencyWithdraw(PID);\n    conversionContract.leave(sBamboo.balanceOf(address(this)));\n    uint balanceAfter = depositToken.balanceOf(address(this));\n    require(balanceAfter.sub(balanceBefore) >= minReturnAmountAccepted, \"CompoundingBamboo::rescueDeployedFunds\");\n    totalDeposits = balanceAfter;\n    emit Reinvest(totalDeposits, totalSupply);\n    if (DEPOSITS_ENABLED == true && disableDeposits == true) {\n      updateDepositsEnabled(false);\n    }\n  }\n}"
    },
    "contracts/interfaces/IBambooBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IBambooBar {\n    function enter(uint256 _amount) external;\n    function leave(uint256 _share) external;\n    function bamboo() external view returns (address);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}