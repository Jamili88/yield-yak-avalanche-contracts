{
  "language": "Solidity",
  "sources": {
    "contracts/ZeroStrategy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./SnowballERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IZeroRouter02.sol\";\nimport \"./interfaces/IZEROPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract ZeroStrategy is SnowballERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IZeroRouter02 public router;\n  IZEROPair public lpToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IStakingRewards public stakingContract;\n\n  uint public MIN_TOKENS_TO_REINVEST = 20;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n\n  event Deposit(address account, uint amount);\n  event Withdraw(address account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n\n  constructor(address _lpToken, address _rewardToken, address _stakingContract, address _router) {\n    lpToken = IZEROPair(_lpToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IStakingRewards(_stakingContract);\n    router = IZeroRouter02(_router);\n\n    address _token0 = IZEROPair(_lpToken).token0();\n    address _token1 = IZEROPair(_lpToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    IERC20(_rewardToken).approve(_router, uint(-1));\n    IERC20(_token0).approve(_router, uint(-1));\n    IERC20(_token1).approve(_router, uint(-1));\n    IZEROPair(_lpToken).approve(_stakingContract, uint(-1));\n\n    name = string(\n      abi.encodePacked(\n        \"Snowball: \",\n        lpToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit LP tokens to receive Snowball tokens\n   * @param amount Amount of LP tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    lpToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(lpToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeLpTokens(amount);\n    _mint(msg.sender, getSharesForLPTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming Snowball tokens\n   * @param amount Amount of Snowball tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint lpTokenAmount = getLPTokensForShares(amount);\n    if (lpTokenAmount > 0) {\n      _withdrawLpTokens(lpTokenAmount);\n      require(lpToken.transfer(msg.sender, lpTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(amount);\n      emit Withdraw(msg.sender, lpTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate Snowball tokens for a given amount of LP tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of LP tokens\n   * @param amount LP tokens\n   * @return Snowball tokens\n   */\n  function getSharesForLPTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate LP tokens for a given amount of Snowball tokens\n   * @param amount Snowball tokens\n   * @return LP tokens\n   */\n  function getLPTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Unclaimed rewards from staking contract\n   * @return Unclaimed rewards from staking contract\n   */\n  function checkReward() public view returns (uint) {\n    return stakingContract.earned(address(this));\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to LP tokens\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    stakingContract.getReward();\n\n    uint adminFee = unclaimedRewards.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToLpTokens(unclaimedRewards.sub(adminFee).sub(reinvestFee));\n    _stakeLpTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to LP tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return LP tokens received\n   */\n  function _convertRewardTokensToLpTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[1], path1[1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes LP tokens in Staking Contract\n   * @param amount LP tokens to stake\n   */\n  function _stakeLpTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.stake(amount);\n  }\n\n  /**\n   * @notice Withdraws LP tokens from Staking Contract\n   * @dev Rewards are not automatically collected from the Staking Contract\n   * @param amount LP tokens to remove;\n   */\n  function _withdrawLpTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.exit();\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/SnowballERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\n\nabstract contract SnowballERC20 {\n    using SafeMath for uint256;\n\n    string public name = \"Snowball\";\n    string public symbol = \"SNOW\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n  \n    mapping (address => mapping (address => uint256)) internal allowances;\n    mapping (address => uint256) internal balances;\n\n    /// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// keccak256(\"1\");\n    bytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    mapping(address => uint) public nonces;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {}\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * It is recommended to use increaseAllowance and decreaseAllowance instead\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowances[src][spender];\n\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = spenderAllowance.sub(amount, \"transferFrom: transfer amount exceeds allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n\n    /**\n     * @notice Approval implementation\n     * @param owner The address of the account which owns tokens\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"_approve::owner zero address\");\n        require(spender != address(0), \"_approve::spender zero address\");\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Transfer implementation\n     * @param from The address of the account which owns tokens\n     * @param to The address of the account which is receiving tokens\n     * @param value The number of tokens that are being transferred\n     */\n    function _transferTokens(address from, address to, uint256 value) internal {\n        require(to != address(0), \"_transferTokens: cannot transfer to the zero address\");\n\n        balances[from] = balances[from].sub(value, \"_transferTokens: transfer exceeds from balance\");\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balances[from] = balances[from].sub(value, \"_burn: burn amount exceeds from balance\");\n        totalSupply = totalSupply.sub(value, \"_burn: burn amount exceeds total supply\");\n        emit Transfer(from, address(0), value);\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spender\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param value The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"permit::expired\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @notice Recovers address from signed data and validates the signature\n     * @param signer Address that signed the data\n     * @param encodeData Data signed by the address\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"Arch::validateSig: invalid signature\");\n    }\n\n    /**\n     * @notice EIP-712 Domain separator\n     * @return Separator\n     */\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                VERSION_HASH,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Current id of the chain where this contract is deployed\n     * @return Chain id\n     */\n    function _getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IStakingRewards {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function lastTimeRewardApplicable() external view returns (uint256);\n    function rewardPerToken() external view returns (uint256);\n    function earned(address account) external view returns (uint256);\n    function getRewardForDuration() external view returns (uint256);\n    function stake(uint256 amount) external;\n    function stakeWithPermit(uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function withdraw(uint256 amount) external;\n    function getReward() external;\n    function exit() external;\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n}"
    },
    "contracts/interfaces/IZeroRouter02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport './IZeroRouter01.sol';\n\ninterface IZeroRouter02 is IZeroRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"
    },
    "contracts/interfaces/IZEROPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IZEROPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"
    },
    "contracts/interfaces/IZeroRouter01.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IZeroRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/lib/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}