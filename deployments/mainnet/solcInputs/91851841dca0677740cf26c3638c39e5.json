{
  "language": "Solidity",
  "sources": {
    "contracts/strategies/BambooLPWithReinvestFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../interfaces/IBambooChef.sol\";\nimport \"../interfaces/IRouter.sol\";\nimport \"../interfaces/IPair.sol\";\nimport \"./BaseStrategy.sol\";\n\ncontract BambooLPWithReinvestFee is BaseStrategy {\n    using SafeMath for uint;\n\n    uint public PID;\n    uint public REINVEST_REWARD_BIPS = 500;\n    uint public ADMIN_FEE_BIPS = 500;\n    uint public MIN_TOKENS_TO_REINVEST = 20000;\n\n    address public feeCollector;\n    IBambooChef public stakingContract;\n    IRouter public router;\n\n    event UpdateAdminFee(uint oldValue, uint newValue);\n    event UpdateReinvestReward(uint oldValue, uint newValue);\n    event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n\n    constructor(\n        string memory _name,\n        address _vault,\n        address _depositToken,\n        address _rewardToken,\n        address _stakingContract,\n        address _router,\n        uint _pid\n    ) {\n        vault = _vault;\n        depositToken = IERC20(_depositToken);\n        rewardToken = IERC20(_rewardToken);\n\n        stakingContract = IBambooChef(_stakingContract);\n        router = IRouter(_router);\n        PID = _pid;\n\n        strategyManager = msg.sender;\n        feeCollector = msg.sender;\n\n        name = _name;\n        setAllowances();\n    }\n\n    function setAllowances() public override onlyManager {\n        depositToken.approve(vault, UINT_MAX);\n        depositToken.approve(address(stakingContract), UINT_MAX);\n        depositToken.approve(address(router), UINT_MAX);\n\n        rewardToken.approve(address(router), UINT_MAX);\n\n        IERC20 token0 = IERC20(IPair(address(depositToken)).token0());\n        token0.approve(address(router), UINT_MAX);\n\n        IERC20 token1 = IERC20(IPair(address(depositToken)).token1());\n        token1.approve(address(router), UINT_MAX);\n    }\n\n    function deposit(uint amount) external override onlyVault {\n        require(depositToken.transferFrom(msg.sender, address(this), amount), \"Strategy::deposit, transferFrom failed\");\n        _stakeDepositTokens(amount);\n    }\n\n    function withdraw(address account, uint amount) external override onlyVault {\n        _withdrawDepositTokens(amount);\n        require(depositToken.transfer(account, amount), \"Strategy::withdraw, transfer failed\");\n    }\n\n    function reinvest() external override onlyVault returns (uint) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards < MIN_TOKENS_TO_REINVEST) {\n            return 0;\n        }\n        return _reinvest(unclaimedRewards);\n    }\n\n    function estimateReinvestReward() external override view returns (uint) {\n        uint unclaimedRewards = checkReward();\n        if (unclaimedRewards < MIN_TOKENS_TO_REINVEST) {\n            return 0;\n        }\n        return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n\n    /**\n     * @notice Reward token balance that can be reinvested\n     * @dev Staking rewards accurue to contract on each deposit/withdrawal\n     * @return Unclaimed rewards, plus contract balance\n     */\n    function checkReward() public override view returns (uint) {\n        uint pendingReward = stakingContract.pendingBamboo(PID, address(this));\n        uint contractBalance = rewardToken.balanceOf(address(this));\n        return pendingReward.add(contractBalance);\n    }\n\n    function getDeployedBalance() external override view returns (uint) {\n        (uint amount,) = stakingContract.userInfo(PID, address(this));\n        return amount;\n    }\n\n    /**\n     * @notice Reinvest rewards from staking contract to deposit tokens\n     * @dev This private function does not require mininmum tokens to be met\n     * @dev Reward should go to tx.origin\n     * @param amount reward tokens\n     * @return deposit tokens reinvested\n     */\n    function _reinvest(uint amount) private returns (uint) {\n        stakingContract.deposit(PID, 0);\n\n        uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n        if (adminFee > 0) {\n            require(rewardToken.transfer(feeCollector, adminFee), \"Strategy::_reinvest, admin fee transfer failed\");\n        }\n\n        uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n        if (reinvestFee > 0) {\n            require(rewardToken.transfer(tx.origin, reinvestFee), \"Strategy::_reinvest, reinvest reward transfer failed\");\n        }\n\n        uint depositTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n        _stakeDepositTokens(depositTokenAmount);\n        return depositTokenAmount;\n    }\n\n    /**\n     * @notice Stakes deposit tokens in Staking Contract\n     * @param amount deposit tokens to stake\n     */\n    function _stakeDepositTokens(uint amount) private {\n        require(amount > 0, \"Strategy::_stakeDepositTokens, amount too low\");\n        stakingContract.deposit(PID, amount);\n    }\n\n    /**\n     * @notice Withdraws deposit tokens from Staking Contract\n     * @dev Reward tokens are automatically collected\n     * @dev Reward tokens are not automatically reinvested\n     * @param amount deposit tokens to remove\n     */\n    function _withdrawDepositTokens(uint amount) private {\n        require(amount > 0, \"Strategy::_withdrawDepositTokens, amount too low\");\n        stakingContract.withdraw(PID, amount);\n    }\n\n    /**\n     * @notice Converts entire reward token balance to deposit tokens\n     * @dev Always converts through router; there are no price checks enabled\n     * @return deposit tokens received\n     */\n    function _convertRewardTokensToDepositTokens(uint amount) private returns (uint) {\n        uint amountIn = amount.div(2);\n        require(amountIn > 0, \"amount too low\");\n\n        // swap to token0\n        address token0 = IPair(address(depositToken)).token0();\n        address[] memory path0 = new address[](2);\n        path0[0] = address(rewardToken);\n        path0[1] = token0;\n\n        uint amountOutToken0 = amountIn;\n        if (path0[0] != path0[1]) {\n            uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n            amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n            router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n        }\n\n        // swap to token1\n        address token1 = IPair(address(depositToken)).token1();\n        address[] memory path1 = new address[](2);\n        path1[0] = path0[0];\n        path1[1] = token1;\n\n        uint amountOutToken1 = amountIn;\n        if (path1[0] != path1[1]) {\n            uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n            amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n            router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n        }\n\n        (,,uint liquidity) = router.addLiquidity(\n            path0[1], path1[1],\n            amountOutToken0, amountOutToken1,\n            0, 0,\n            address(this),\n            block.timestamp\n        );\n\n        return liquidity;\n    }\n\n    /**\n     * @notice Update reinvest minimum threshold for external callers\n     * @param newValue min threshold in wei\n     */\n    function updateMinTokensToReinvest(uint newValue) external onlyManager {\n        emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n        MIN_TOKENS_TO_REINVEST = newValue;\n    }\n\n    /**\n     * @notice Update admin fee\n     * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n     * @param newValue specified in BIPS\n     */\n    function updateAdminFee(uint newValue) external onlyManager {\n        require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n        emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n        ADMIN_FEE_BIPS = newValue;\n    }\n\n    /**\n     * @notice Update reinvest reward\n     * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n     * @param newValue specified in BIPS\n     */\n    function updateReinvestReward(uint newValue) external onlyManager {\n        require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n        emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n        REINVEST_REWARD_BIPS = newValue;\n    }\n\n    function rescueDeployedFunds() external override onlyManagerOrVault {\n        stakingContract.emergencyWithdraw(PID);\n    }\n}"
    },
    "contracts/interfaces/IBambooChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IBambooChef {\n    function bamboo() external view returns (address);\n    function bambooPerBlock() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function add(uint256 _allocPoint, address _lpToken, bool _withUpdate) external;\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n    function setMigrator(address _migrator) external;\n    function migrate(uint256 _pid) external;\n    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n    function pendingBamboo(uint256 _pid, address _user) external view returns (uint256);\n    function massUpdatePools() external;\n    function updatePool(uint256 _pid) external;\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function dev(address _devaddr) external;\n    function poolInfo(uint pid) external view returns (\n        address lpToken,\n        uint allocPoint,\n        uint lastRewardBlock,\n        uint accSushiPerShare\n    );\n    function userInfo(uint pid, address user) external view returns (\n        uint256 amount,\n        uint256 rewardDebt\n    );\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n}"
    },
    "contracts/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IRouter {\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(address token, uint amountTokenDesired, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountAVAX);\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/interfaces/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\n\ninterface IPair is IERC20 {\n    function token0() external pure returns (address);\n    function token1() external pure returns (address);\n}\n"
    },
    "contracts/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../lib/SafeMath.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nabstract contract BaseStrategy {\n    using SafeMath for uint;\n\n    IERC20 public depositToken;\n    IERC20 public rewardToken;\n    address public vault;\n    address public strategyManager;\n    string public name;\n\n    uint constant internal BIPS_DIVISOR = 10000;\n    uint constant internal UINT_MAX = uint256(-1);\n\n    /**\n     * @dev May only be called by `vault`\n     */\n    modifier onlyVault() {\n        require(msg.sender == vault, \"onlyVault\");\n        _;\n    }\n\n    /**\n     * @dev May only be called by `strategyManager`\n     */\n    modifier onlyManager() {\n        require(msg.sender == strategyManager, \"onlyManager\");\n        _;\n    }\n\n    /**\n     * @dev May only be called by `strategyManager` or `vault`\n     */\n    modifier onlyManagerOrVault() {\n        require(\n            msg.sender == strategyManager\n            || msg.sender == vault\n            , \"onlyManagerOrVault\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Approve tokens for use in Strategy\n     * @dev Restricted to avoid griefing attacks\n     */\n    function setAllowances() public virtual;\n\n    /**\n     * @notice Revoke token allowance\n     * @dev Restricted to avoid griefing attacks\n     * @param token address\n     * @param spender address\n     */\n    function revokeAllowance(address token, address spender) external onlyManager {\n        require(IERC20(token).approve(spender, 0));\n    }\n\n    /**\n     * @notice Deposits `depositToken` to strategy\n     * @param amount deposit tokens to deposit to strategy\n     */\n    function deposit(uint amount) external virtual;\n\n    /**\n     * @notice Withdraws `depositTokens` from strategy\n     * @param account account to receive deposit tokens\n     * @param amount deposit tokens to withdraw from strategy\n     */\n    function withdraw(address account, uint amount) external virtual;\n\n    /**\n     * @notice Reinvests `rewardToken` to `depositToken`\n     * @return deposit tokens received\n     */\n    function reinvest() external virtual returns (uint);\n\n    /**\n     * @notice Estimate reinvest reward for caller\n     * @return Estimated rewards tokens earned for calling `reinvest()`\n     */\n    function estimateReinvestReward() external virtual view returns (uint);\n\n    /**\n     * @notice Reward token balance that can be reinvested\n     * @return reward tokens\n     */\n    function checkReward() public virtual view returns (uint);\n\n    /**\n     * @notice Helper function to get the current balance deployed by strategy\n     * @dev This must NOT include the strategy contract balance\n     * @return deposit tokens\n     */\n    function getDeployedBalance() external virtual view returns (uint);\n\n    /**\n     * @notice Rescue all available deployed deposit tokens back to Strategy\n     * @dev This is should NOT transfer tokens out of the strategy contract\n     */\n    function rescueDeployedFunds() external virtual;\n\n    /**\n     * @notice Recover ERC20 from contract\n     * @param tokenAddress token address\n     * @param tokenAmount amount to recover\n     */\n    function recoverERC20(address tokenAddress, uint tokenAmount) external onlyVault {\n        require(tokenAmount > 0, 'Strategy::recoverERC20, amount too low');\n        require(IERC20(tokenAddress).transfer(msg.sender, tokenAmount));\n    }\n\n    /**\n     * @notice Recover AVAX from contract\n     * @param amount amount\n     */\n    function recoverAVAX(uint amount) external onlyVault {\n        require(amount > 0, 'Strategy::recoverAVAX, amount too low');\n        require(amount <= address(this).balance, \"Strategy::recoverAVAX, amount too high\");\n        msg.sender.transfer(amount);\n    }\n\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}