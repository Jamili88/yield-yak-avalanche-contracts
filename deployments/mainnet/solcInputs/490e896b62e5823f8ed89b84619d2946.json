{
  "language": "Solidity",
  "sources": {
    "contracts/timelocks/YakTimelockForDexStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IStrategy {\n    function owner() external view returns (address);\n    function renounceOwnership() external;\n    function transferOwnership(address newOwner) external;\n    function emergencyWithdraw() external;\n    function updateMinTokensToReinvest(uint newValue) external;\n    function updateAdminFee(uint newValue) external;\n    function updateReinvestReward(uint newValue) external;\n    function recoverERC20(address tokenAddress, uint tokenAmount) external;\n    function recoverAVAX(uint amount) external;\n}\n\ncontract YakTimelockForDexStrategyV2 {\n\n    uint public constant timelockLengthForAssetRecovery = 2 minutes;\n    uint public constant timelockLengthForOwnershipTransfer = 5 minutes;\n    uint public constant timelockLengthForFeeChanges = 1 minutes;\n\n    address public manager;\n    address public feeCollector;\n\n    mapping(address => address) public pendingOwners;\n    mapping(address => uint) public pendingAdminFees;\n    mapping(address => uint) public pendingReinvestRewards;\n    mapping(address => address) public pendingTokenAddressesToRecover;\n    mapping(address => uint) public pendingTokenAmountsToRecover;\n    mapping(address => uint) public pendingAVAXToRecover;\n\n    event ProposeOwner(address indexed strategy, address indexed proposedValue, uint timelock);\n    event ProposeAdminFee(address indexed strategy, uint proposedValue, uint timelock);\n    event ProposeReinvestReward(address indexed strategy, uint proposedValue, uint timelock);\n    event ProposeRecovery(address indexed strategy, address indexed proposedToken, uint proposedValue, uint timelock);\n\n    event SetOwner(address indexed strategy, address indexed newValue);\n    event SetAdminFee(address indexed strategy, uint newValue);\n    event SetReinvestReward(address indexed strategy, uint newValue);\n    event SetMinTokensToReinvest(address indexed strategy, uint newValue);\n    event Sweep(address indexed token, uint amount);\n    event Recover(address indexed strategy, address indexed token, uint amount);\n    event EmergencyWithdraw(address indexed strategy);\n\n    enum Functions {\n        renounceOwnership,\n        transferOwnership,\n        emergencyWithdraw,\n        updateMinTokensToReinvest,\n        updateAdminFee,\n        updateReinvestReward,\n        recoverERC20,\n        recoverAVAX\n    }\n\n    mapping(address => mapping(Functions => uint)) public timelock;\n\n    constructor() {\n        manager = msg.sender;\n        feeCollector = msg.sender;\n    }\n\n    // Modifiers\n\n    /**\n     * @notice Restrict to `manager`\n     * @dev To change manager, deploy new timelock and transfer strategy ownership\n     */\n    modifier onlyManager {\n        require(msg.sender == manager);\n        _;\n    }\n\n    /**\n     * @notice Restrict to `feeCollector`\n     * @dev To change feeCollector, deploy new timelock and transfer strategy ownership\n     */\n    modifier onlyFeeCollector {\n        require(msg.sender == feeCollector);\n        _;\n    }\n\n    /**\n     * @notice Set timelock when changing pending values\n     * @param _strategy address\n     * @param _fn Function enum value\n     * @param timelockLength in seconds\n     */\n    modifier setTimelock(address _strategy, Functions _fn, uint timelockLength) {\n        timelock[_strategy][_fn] = block.timestamp + timelockLength;\n        _;\n    }\n\n    /**\n     * @notice Enforce timelock for a given function\n     * @dev Ends execution by resetting timelock to avoid replay\n     * @param _strategy address\n     * @param _fn Function enum value\n     */\n    modifier enforceTimelock(address _strategy, Functions _fn) {\n        require(timelock[_strategy][_fn] != 0 && timelock[_strategy][_fn] <= block.timestamp, \"YakTimelockManager::enforceTimelock\");\n        _;\n        timelock[_strategy][_fn] = 0;\n    }\n\n    /**\n     * @notice Sweep tokens from the timelock to `feeCollector`\n     * @dev The timelock contract may receive assets from both revenue and asset recovery.\n     * @dev The sweep function is NOT timelocked, because recovered assets must go through separate timelock functions.\n     * @param tokenAddress address\n     * @param tokenAmount amount\n     */\n    function sweepTokens(address tokenAddress, uint tokenAmount) external onlyFeeCollector {\n        require(tokenAmount > 0, \"YakTimelockManager::sweepTokens, amount too low\");\n        require(IERC20(tokenAddress).transfer(msg.sender, tokenAmount), \"YakTimelockManager::sweepTokens, transfer failed\");\n        emit Sweep(tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Sweep AVAX from the timelock to the `feeCollector` address\n     * @dev The timelock contract may receive assets from both revenue and asset recovery.\n     * @dev The sweep function is NOT timelocked, because recovered assets must go through separate timelock functions.\n     * @param amount amount\n     */\n    function sweepAVAX(uint amount) external onlyFeeCollector {\n        require(amount > 0, 'YakTimelockManager::sweepAVAX, amount too low');\n        msg.sender.transfer(amount);\n        emit Sweep(address(0), amount);\n    }\n\n    // Functions with timelocks\n\n    /**\n     * @notice Pass new value of `owner` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _strategy address\n     * @param _pendingOwner new value\n     */\n    function proposeOwner(address _strategy, address _pendingOwner) external onlyManager \n    setTimelock(_strategy, Functions.transferOwnership, timelockLengthForOwnershipTransfer) {\n        pendingOwners[_strategy] = _pendingOwner;\n        emit ProposeOwner(_strategy, _pendingOwner, timelock[_strategy][Functions.transferOwnership]);\n    }\n\n    /**\n     * @notice Set new value of `owner` and resets timelock\n     * @dev This can be called by anyone\n     * @param _strategy address\n     */\n    function setOwner(address _strategy) external \n    enforceTimelock(_strategy, Functions.transferOwnership) {\n        IStrategy(_strategy).transferOwnership(pendingOwners[_strategy]);\n        emit SetOwner(_strategy, pendingOwners[_strategy]);\n        pendingOwners[_strategy] = address(0);\n    }\n\n    /**\n     * @notice Pass new value of `adminFee` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _strategy address\n     * @param _pendingAdminFee new value\n     */\n    function proposeAdminFee(address _strategy, uint _pendingAdminFee) external onlyManager \n    setTimelock(_strategy, Functions.updateAdminFee, timelockLengthForFeeChanges) {\n        pendingAdminFees[_strategy] = _pendingAdminFee;\n        emit ProposeAdminFee(_strategy, _pendingAdminFee, timelock[_strategy][Functions.updateAdminFee]);\n    }\n\n    /**\n     * @notice Set new value of `adminFee` and reset timelock\n     * @dev This can be called by anyone\n     * @param _strategy address\n     */\n    function setAdminFee(address _strategy) external \n    enforceTimelock(_strategy, Functions.updateAdminFee) {\n        IStrategy(_strategy).updateAdminFee(pendingAdminFees[_strategy]);\n        emit SetAdminFee(_strategy, pendingAdminFees[_strategy]);\n        pendingAdminFees[_strategy] = 0;\n    }\n\n    /**\n     * @notice Pass new value of `reinvestReward` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _strategy address\n     * @param _pendingReinvestReward new value\n     */\n    function proposeReinvestReward(address _strategy, uint _pendingReinvestReward) external onlyManager \n    setTimelock(_strategy, Functions.updateReinvestReward, timelockLengthForFeeChanges) {\n        pendingReinvestRewards[_strategy] = _pendingReinvestReward;\n        emit ProposeReinvestReward(_strategy, _pendingReinvestReward, timelock[_strategy][Functions.updateReinvestReward]);\n    }\n\n    /**\n     * @notice Set new value of `reinvestReward` and reset timelock\n     * @dev This can be called by anyone\n     * @param _strategy address\n     */\n    function setReinvestReward(address _strategy) external \n    enforceTimelock(_strategy, Functions.updateReinvestReward) {\n        IStrategy(_strategy).updateReinvestReward(pendingReinvestRewards[_strategy]);\n        emit SetReinvestReward(_strategy, pendingReinvestRewards[_strategy]);\n        pendingReinvestRewards[_strategy] = 0;\n    }\n\n    /**\n     * @notice Pass values for `recoverERC20` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _strategy address\n     * @param _pendingTokenAddressToRecover address\n     * @param _pendingTokenAmountToRecover amount\n     */\n    function proposeRecoverERC20(address _strategy, address _pendingTokenAddressToRecover, uint _pendingTokenAmountToRecover) external onlyManager \n    setTimelock(_strategy, Functions.recoverERC20, timelockLengthForAssetRecovery) {\n        pendingTokenAddressesToRecover[_strategy] = _pendingTokenAddressToRecover;\n        pendingTokenAmountsToRecover[_strategy] = _pendingTokenAmountToRecover;\n        emit ProposeRecovery(_strategy, _pendingTokenAddressToRecover, _pendingTokenAmountToRecover, timelock[_strategy][Functions.recoverERC20]);\n    }\n\n    /**\n     * @notice Call `recoverERC20` and reset timelock\n     * @dev This can be called by anyone\n     * @dev Recoverd funds are collected to this timelock and may be swept\n     * @param _strategy address\n     */\n    function setRecoverERC20(address _strategy) external \n    enforceTimelock(_strategy, Functions.recoverERC20) {\n        IStrategy(_strategy).recoverERC20(pendingTokenAddressesToRecover[_strategy], pendingTokenAmountsToRecover[_strategy]);\n        emit Recover(_strategy, pendingTokenAddressesToRecover[_strategy], pendingTokenAmountsToRecover[_strategy]);\n        pendingTokenAddressesToRecover[_strategy] = address(0);\n        pendingTokenAmountsToRecover[_strategy] = 0;\n    }\n\n    /**\n     * @notice Pass values for `recoverAVAX` through timelock\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev Resets timelock duration through modifier\n     * @param _strategy address\n     * @param _pendingAVAXToRecover amount\n     */\n    function proposeRecoverAVAX(address _strategy, uint _pendingAVAXToRecover) external onlyManager \n    setTimelock(_strategy, Functions.recoverAVAX, timelockLengthForAssetRecovery) {\n        pendingAVAXToRecover[_strategy] = _pendingAVAXToRecover;\n        emit ProposeRecovery(_strategy, address(0), _pendingAVAXToRecover, timelock[_strategy][Functions.recoverAVAX]);\n    }\n\n    /**\n     * @notice Call `recoverAVAX` and reset timelock\n     * @dev This can be called by anyone\n     * @dev Recoverd funds are collected to this timelock and may be swept\n     * @param _strategy address\n     */\n    function setRecoverAVAX(address _strategy) external \n    enforceTimelock(_strategy, Functions.recoverAVAX) {\n        IStrategy(_strategy).recoverAVAX(pendingAVAXToRecover[_strategy]);\n        emit Recover(_strategy, address(0), pendingAVAXToRecover[_strategy]);\n        pendingAVAXToRecover[_strategy] = 0;\n    }\n\n    // Functions without timelocks\n\n    /**\n     * @notice Set new value of `minTokensToReinvest`\n     * @dev Restricted to `manager` to avoid griefing\n     * @param _strategy address\n     * @param minTokensToReinvest new value\n     */\n    function setMinTokensToReinvest(address _strategy, uint minTokensToReinvest) external onlyManager {\n        IStrategy(_strategy).updateMinTokensToReinvest(minTokensToReinvest);\n        emit SetMinTokensToReinvest(_strategy, minTokensToReinvest);\n    }\n\n    /**\n     * @notice Rescues deployed assets to the strategy contract\n     * @dev Restricted to `manager` to avoid griefing\n     * @dev In case of emergency, assets will be transferred to the timelock and may be swept\n     * @param _strategy address\n     */\n    function emergencyWithdraw(address _strategy) external onlyManager {\n        IStrategy(_strategy).emergencyWithdraw();\n        emit EmergencyWithdraw(_strategy);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}