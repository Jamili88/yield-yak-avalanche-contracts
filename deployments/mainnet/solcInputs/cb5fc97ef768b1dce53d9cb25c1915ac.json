{
  "language": "Solidity",
  "sources": {
    "contracts/OliveStrategyForLPb.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IOliveChef.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract OliveStrategyForLPb is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IOliveChef public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  uint constant private UINT_MAX = uint256(-1);\n  address constant private WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IOliveChef(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_depositToken).token0();\n    address _token1 = IPair(_depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    setAllowances();\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public onlyOwner {\n    depositToken.approve(address(stakingContract), UINT_MAX);\n    rewardToken.approve(address(router), UINT_MAX);\n    token0.approve(address(router), UINT_MAX);\n    token1.approve(address(router), UINT_MAX);\n  }\n\n  /**\n    * @notice Revoke token allowance\n    * @dev Restricted to avoid griefing attacks\n    * @param token address\n    * @param spender address\n    */\n  function revokeAllowance(address token, address spender) external onlyOwner {\n    require(IERC20(token).approve(spender, 0));\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingOlive(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](2);\n    path0[0] = address(rewardToken);\n    path0[1] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0.length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](3);\n    path1[0] = path0[0];\n    path1[1] = WAVAX;\n    path1[2] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1.length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0.length - 1], path1[path1.length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    require(tokenAddress != address(depositToken), \"cannot recover deposit token\");\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    },
    "contracts/YakERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\n\nabstract contract YakERC20 {\n    using SafeMath for uint256;\n\n    string public name = \"Yield Yak\";\n    string public symbol = \"YRT\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n  \n    mapping (address => mapping (address => uint256)) internal allowances;\n    mapping (address => uint256) internal balances;\n\n    /// keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// keccak256(\"1\");\n    bytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    /// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    mapping(address => uint) public nonces;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {}\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * It is recommended to use increaseAllowance and decreaseAllowance instead\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowances[src][spender];\n\n        if (spender != src && spenderAllowance != uint256(-1)) {\n            uint256 newAllowance = spenderAllowance.sub(amount, \"transferFrom: transfer amount exceeds allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n\n    /**\n     * @notice Approval implementation\n     * @param owner The address of the account which owns tokens\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"_approve::owner zero address\");\n        require(spender != address(0), \"_approve::spender zero address\");\n        allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Transfer implementation\n     * @param from The address of the account which owns tokens\n     * @param to The address of the account which is receiving tokens\n     * @param value The number of tokens that are being transferred\n     */\n    function _transferTokens(address from, address to, uint256 value) internal {\n        require(to != address(0), \"_transferTokens: cannot transfer to the zero address\");\n\n        balances[from] = balances[from].sub(value, \"_transferTokens: transfer exceeds from balance\");\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balances[from] = balances[from].sub(value, \"_burn: burn amount exceeds from balance\");\n        totalSupply = totalSupply.sub(value, \"_burn: burn amount exceeds total supply\");\n        emit Transfer(from, address(0), value);\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spender\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param value The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"permit::expired\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @notice Recovers address from signed data and validates the signature\n     * @param signer Address that signed the data\n     * @param encodeData Data signed by the address\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"Arch::validateSig: invalid signature\");\n    }\n\n    /**\n     * @notice EIP-712 Domain separator\n     * @return Separator\n     */\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                VERSION_HASH,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Current id of the chain where this contract is deployed\n     * @return Chain id\n     */\n    function _getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/interfaces/IOliveChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IOliveChef {\n    function olive() external view returns (address);\n    function olivePerBlock() external view returns (uint256);\n\n    function poolLength() external view returns (uint256);\n    function add(uint256 _allocPoint, address _lpToken, bool _withUpdate) external;\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external;\n    function getMultiplier(uint256 _from, uint256 _to) external view returns (uint256);\n    function pendingOlive(uint256 _pid, address _user) external view returns (uint256);\n    function massUpdatePools() external;\n    function updatePool(uint256 _pid) external;\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function dev(address _devaddr) external;\n    function poolInfo(uint pid) external view returns (\n        address lpToken,\n        uint allocPoint,\n        uint lastRewardBlock,\n        uint accOlivePerShare\n    );\n    function userInfo(uint pid, address user) external view returns (\n        uint256 amount,\n        uint256 rewardDebt\n    );\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n}"
    },
    "contracts/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IRouter {\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityAVAX(address token, uint amountTokenDesired, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAX(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\n    function removeLiquidityAVAXWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountAVAX);\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline) external returns (uint amountAVAX);\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountAVAXMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountAVAX);\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/interfaces/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\n\ninterface IPair is IERC20 {\n    function token0() external pure returns (address);\n    function token1() external pure returns (address);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"
    },
    "contracts/lib/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"
    },
    "contracts/OliveStrategyForLPa.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./YakERC20.sol\";\nimport \"./lib/SafeMath.sol\";\nimport \"./interfaces/IOliveChef.sol\";\nimport \"./interfaces/IRouter.sol\";\nimport \"./interfaces/IPair.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./lib/Ownable.sol\";\n\ncontract OliveStrategyForLPa is YakERC20, Ownable {\n  using SafeMath for uint;\n\n  uint public totalDeposits;\n\n  IRouter public router;\n  IPair public depositToken;\n  IERC20 private token0;\n  IERC20 private token1;\n  IERC20 public rewardToken;\n  IOliveChef public stakingContract;\n\n  uint public PID;\n  uint public MIN_TOKENS_TO_REINVEST = 20000;\n  uint public REINVEST_REWARD_BIPS = 500;\n  uint public ADMIN_FEE_BIPS = 500;\n  uint constant private BIPS_DIVISOR = 10000;\n  uint constant private UINT_MAX = uint256(-1);\n  address constant private WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n  bool public REQUIRE_REINVEST_BEFORE_DEPOSIT;\n  uint public MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = 20;\n\n  event Deposit(address indexed account, uint amount);\n  event Withdraw(address indexed account, uint amount);\n  event Reinvest(uint newTotalDeposits, uint newTotalSupply);\n  event Recovered(address token, uint amount);\n  event UpdateAdminFee(uint oldValue, uint newValue);\n  event UpdateReinvestReward(uint oldValue, uint newValue);\n  event UpdateMinTokensToReinvest(uint oldValue, uint newValue);\n  event UpdateRequireReinvestBeforeDeposit(bool newValue);\n  event UpdateMinTokensToReinvestBeforeDeposit(uint oldValue, uint newValue);\n\n  constructor(\n    address _depositToken, \n    address _rewardToken, \n    address _stakingContract,\n    address _router,\n    uint _pid\n  ) {\n    depositToken = IPair(_depositToken);\n    rewardToken = IERC20(_rewardToken);\n    stakingContract = IOliveChef(_stakingContract);\n    router = IRouter(_router);\n\n    PID = _pid;\n\n    address _token0 = IPair(_depositToken).token0();\n    address _token1 = IPair(_depositToken).token1();\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n\n    name = string(\n      abi.encodePacked(\n        \"Yield Yak: \",\n        depositToken.symbol(), \" \",\n        IERC20(_token0).symbol(), \"-\",\n        IERC20(_token1).symbol()\n      )\n    );\n\n    setAllowances();\n    emit Reinvest(0, 0);\n  }\n\n  /**\n    * @dev Throws if called by smart contract\n    */\n  modifier onlyEOA() {\n      require(tx.origin == msg.sender, \"onlyEOA\");\n      _;\n  }\n\n  /**\n   * @notice Approve tokens for use in Strategy\n   * @dev Restricted to avoid griefing attacks\n   */\n  function setAllowances() public onlyOwner {\n    depositToken.approve(address(stakingContract), UINT_MAX);\n    rewardToken.approve(address(router), UINT_MAX);\n    token0.approve(address(router), UINT_MAX);\n    token1.approve(address(router), UINT_MAX);\n  }\n\n  /**\n    * @notice Revoke token allowance\n    * @dev Restricted to avoid griefing attacks\n    * @param token address\n    * @param spender address\n    */\n  function revokeAllowance(address token, address spender) external onlyOwner {\n    require(IERC20(token).approve(spender, 0));\n  }\n\n  /**\n   * @notice Deposit tokens to receive receipt tokens\n   * @param amount Amount of tokens to deposit\n   */\n  function deposit(uint amount) external {\n    _deposit(amount);\n  }\n\n  /**\n   * @notice Deposit using Permit\n   * @param amount Amount of tokens to deposit\n   * @param deadline The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function depositWithPermit(uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n    depositToken.permit(msg.sender, address(this), amount, deadline, v, r, s);\n    _deposit(amount);\n  }\n\n  function _deposit(uint amount) internal {\n    require(totalDeposits >= totalSupply, \"deposit failed\");\n    if (REQUIRE_REINVEST_BEFORE_DEPOSIT) {\n      uint unclaimedRewards = checkReward();\n      if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT) {\n        _reinvest(unclaimedRewards);\n      }\n    }\n    require(depositToken.transferFrom(msg.sender, address(this), amount), \"transferFrom failed\");\n    _stakeDepositTokens(amount);\n    _mint(msg.sender, getSharesForDepositTokens(amount));\n    totalDeposits = totalDeposits.add(amount);\n    emit Deposit(msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw LP tokens by redeeming receipt tokens\n   * @param amount Amount of receipt tokens to redeem\n   */\n  function withdraw(uint amount) external {\n    uint depositTokenAmount = getDepositTokensForShares(amount);\n    if (depositTokenAmount > 0) {\n      _withdrawDepositTokens(depositTokenAmount);\n      require(depositToken.transfer(msg.sender, depositTokenAmount), \"transfer failed\");\n      _burn(msg.sender, amount);\n      totalDeposits = totalDeposits.sub(depositTokenAmount);\n      emit Withdraw(msg.sender, depositTokenAmount);\n    }\n  }\n\n  /**\n   * @notice Calculate receipt tokens for a given amount of deposit tokens\n   * @dev If contract is empty, use 1:1 ratio\n   * @dev Could return zero shares for very low amounts of deposit tokens\n   * @param amount deposit tokens\n   * @return receipt tokens\n   */\n  function getSharesForDepositTokens(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return amount;\n    }\n    return amount.mul(totalSupply).div(totalDeposits);\n  }\n\n  /**\n   * @notice Calculate deposit tokens for a given amount of receipt tokens\n   * @param amount receipt tokens\n   * @return deposit tokens\n   */\n  function getDepositTokensForShares(uint amount) public view returns (uint) {\n    if (totalSupply.mul(totalDeposits) == 0) {\n      return 0;\n    }\n    return amount.mul(totalDeposits).div(totalSupply);\n  }\n\n  /**\n   * @notice Reward token balance that can be reinvested\n   * @dev Staking rewards accurue to contract on each deposit/withdrawal\n   * @return Unclaimed rewards, plus contract balance\n   */\n  function checkReward() public view returns (uint) {\n    uint pendingReward = stakingContract.pendingOlive(PID, address(this));\n    uint contractBalance = rewardToken.balanceOf(address(this));\n    return pendingReward.add(contractBalance);\n  }\n\n  /**\n   * @notice Estimate reinvest reward for caller\n   * @return Estimated rewards tokens earned for calling `reinvest()`\n   */\n  function estimateReinvestReward() external view returns (uint) {\n    uint unclaimedRewards = checkReward();\n    if (unclaimedRewards >= MIN_TOKENS_TO_REINVEST) {\n      return unclaimedRewards.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This external function requires minimum tokens to be met\n   */\n  function reinvest() external onlyEOA {\n    uint unclaimedRewards = checkReward();\n    require(unclaimedRewards >= MIN_TOKENS_TO_REINVEST, \"MIN_TOKENS_TO_REINVEST\");\n    _reinvest(unclaimedRewards);\n  }\n\n  /**\n   * @notice Reinvest rewards from staking contract to deposit tokens\n   * @dev This internal function does not require mininmum tokens to be met\n   */\n  function _reinvest(uint amount) internal {\n    stakingContract.deposit(PID, 0);\n\n    uint adminFee = amount.mul(ADMIN_FEE_BIPS).div(BIPS_DIVISOR);\n    if (adminFee > 0) {\n      require(rewardToken.transfer(owner(), adminFee), \"admin fee transfer failed\");\n    }\n\n    uint reinvestFee = amount.mul(REINVEST_REWARD_BIPS).div(BIPS_DIVISOR);\n    if (reinvestFee > 0) {\n      require(rewardToken.transfer(msg.sender, reinvestFee), \"reinvest fee transfer failed\");\n    }\n\n    uint lpTokenAmount = _convertRewardTokensToDepositTokens(amount.sub(adminFee).sub(reinvestFee));\n    _stakeDepositTokens(lpTokenAmount);\n    totalDeposits = totalDeposits.add(lpTokenAmount);\n\n    emit Reinvest(totalDeposits, totalSupply);\n  }\n\n  /**\n   * @notice Converts entire reward token balance to deposit tokens\n   * @dev Always converts through router; there are no price checks enabled\n   * @return deposit tokens received\n   */\n  function _convertRewardTokensToDepositTokens(uint amount) internal returns (uint) {\n    uint amountIn = amount.div(2);\n    require(amountIn > 0, \"amount too low\");\n\n    // swap to token0\n    address[] memory path0 = new address[](3);\n    path0[0] = address(rewardToken);\n    path0[1] = WAVAX;\n    path0[2] = address(token0);\n\n    uint amountOutToken0 = amountIn;\n    if (path0[0] != path0[path0.length - 1]) {\n      uint[] memory amountsOutToken0 = router.getAmountsOut(amountIn, path0);\n      amountOutToken0 = amountsOutToken0[amountsOutToken0.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken0, path0, address(this), block.timestamp);\n    }\n\n    // swap to token1\n    address[] memory path1 = new address[](2);\n    path1[0] = path0[0];\n    path1[1] = address(token1);\n\n    uint amountOutToken1 = amountIn;\n    if (path1[0] != path1[path1.length - 1]) {\n      uint[] memory amountsOutToken1 = router.getAmountsOut(amountIn, path1);\n      amountOutToken1 = amountsOutToken1[amountsOutToken1.length - 1];\n      router.swapExactTokensForTokens(amountIn, amountOutToken1, path1, address(this), block.timestamp);\n    }\n\n    (,,uint liquidity) = router.addLiquidity(\n      path0[path0.length - 1], path1[path1.length - 1],\n      amountOutToken0, amountOutToken1,\n      0, 0,\n      address(this),\n      block.timestamp\n    );\n\n    return liquidity;\n  }\n\n  /**\n   * @notice Stakes deposit tokens in Staking Contract\n   * @param amount deposit tokens to stake\n   */\n  function _stakeDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.deposit(PID, amount);\n  }\n\n  /**\n   * @notice Withdraws deposit tokens from Staking Contract\n   * @dev Reward tokens are automatically collected\n   * @dev Reward tokens are not automatically reinvested\n   * @param amount deposit tokens to remove\n   */\n  function _withdrawDepositTokens(uint amount) internal {\n    require(amount > 0, \"amount too low\");\n    stakingContract.withdraw(PID, amount);\n  }\n\n  /**\n   * @notice Allows exit from Staking Contract without additional logic\n   * @dev Reward tokens are not automatically collected\n   * @dev New deposits will be effectively disabled\n   */\n  function emergencyWithdraw() external onlyOwner {\n    stakingContract.emergencyWithdraw(PID);\n    totalDeposits = 0;\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold for external callers\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvest(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, newValue);\n    MIN_TOKENS_TO_REINVEST = newValue;\n  }\n\n  /**\n   * @notice Update admin fee\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateAdminFee(uint newValue) external onlyOwner {\n    require(newValue.add(REINVEST_REWARD_BIPS) <= BIPS_DIVISOR, \"admin fee too high\");\n    emit UpdateAdminFee(ADMIN_FEE_BIPS, newValue);\n    ADMIN_FEE_BIPS = newValue;\n  }\n\n  /**\n   * @notice Update reinvest reward\n   * @dev Total fees cannot be greater than BIPS_DIVISOR (100%)\n   * @param newValue specified in BIPS\n   */\n  function updateReinvestReward(uint newValue) external onlyOwner {\n    require(newValue.add(ADMIN_FEE_BIPS) <= BIPS_DIVISOR, \"reinvest reward too high\");\n    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, newValue);\n    REINVEST_REWARD_BIPS = newValue;\n  }\n\n  /**\n   * @notice Toggle requirement to reinvest before deposit\n   */\n  function updateRequireReinvestBeforeDeposit() external onlyOwner {\n    REQUIRE_REINVEST_BEFORE_DEPOSIT = !REQUIRE_REINVEST_BEFORE_DEPOSIT;\n    emit UpdateRequireReinvestBeforeDeposit(REQUIRE_REINVEST_BEFORE_DEPOSIT);\n  }\n\n  /**\n   * @notice Update reinvest minimum threshold before a deposit\n   * @param newValue min threshold in wei\n   */\n  function updateMinTokensToReinvestBeforeDeposit(uint newValue) external onlyOwner {\n    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, newValue);\n    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = newValue;\n  }\n\n  /**\n   * @notice Recover ERC20 from contract\n   * @param tokenAddress token address\n   * @param tokenAmount amount to recover\n   */\n  function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n    require(tokenAmount > 0, 'amount too low');\n    require(tokenAddress != address(depositToken), \"cannot recover deposit token\");\n    IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    emit Recovered(tokenAddress, tokenAmount);\n  }\n\n  /**\n   * @notice Recover AVAX from contract\n   * @param amount amount\n   */\n  function recoverAVAX(uint amount) external onlyOwner {\n    require(amount > 0, 'amount too low');\n    msg.sender.transfer(amount);\n    emit Recovered(address(0), amount);\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}